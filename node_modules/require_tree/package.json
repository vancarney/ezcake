{
  "author": {
    "name": "Van Carney",
    "email": "carney.van@gmail.com"
  },
  "name": "require_tree",
  "description": "Recursive Package like Module and JSON Loading for Nodejs",
  "keywords": [
    "recursive",
    "require",
    "tree",
    "model",
    "filesystem",
    "js",
    "json",
    "import",
    "package",
    "module",
    "loading",
    "export"
  ],
  "version": "0.6.5",
  "main": "require_tree.js",
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/MIT"
    }
  ],
  "repository": {
    "type": "git",
    "url": "github.com/vancarney/require_tree.git"
  },
  "dependencies": {},
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "mocha": "~1.12.0",
    "chai": "~1.7.2",
    "docco": "~0.6.2"
  },
  "homepage": "http://vancarney.github.io/require_tree/",
  "scripts": {
    "test": "cake test"
  },
  "readme": "<!-- === begin markdown block =====================================================\n\n      generated by markdown 1.0.0 on Ruby 1.9.3 (2012-04-20) [x86_64-darwin12.0.0]\n                on 2013-11-08 14:12:02 -0800 with Markdown engine kramdown (0.14.0)\n                  using options { !to be done! }\n  -->\n<h1 id=\"requiretreepath-options\">require_tree([path], [options])</h1>\n\n<p>Recursive Package like Module and JSON Loading for NodeJS</p>\n\n<p><a href=\"https://travis-ci.org/vancarney/require_tree\"><img src=\"https://travis-ci.org/vancarney/require_tree.png\" alt=\"Build Status\" /></a></p>\n\n<h2 id=\"installation\">Installation</h2>\n<pre><code>npm install require_tree\n</code></pre>\n\n<h2 id=\"basic-usage\">Basic Usage</h2>\n\n<p>Given a directory structure as follows</p>\n\n<pre><code>- lib/\n\t- models/\n\t\t- User.js\n\t- controllers/\n\t\t- Login.js\n\t- utils/\n\t\t- index.js\n\t\t- specialUtility.js\n\t- config.json\n</code></pre>\n\n<p>You can import all these in a single <code>require_tree</code> statement and access them via hash syntax like a traditional OO Package</p>\n\n<pre><code>var app = require('require_tree').require_tree('lib');\n \n// models.User is now accessable\n \tvar user  = new app.models.User();\n \n// JSON objects are accessed in the same manner\nvar configVal = app.config.myValue;\n \n// index files are appended directly to the local root\napp.utils.myIndexFunction();\n \n// other files are appended within the same scope\nvar util = new app.utils.specialUtility();\n</code></pre>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p><strong>path</strong>: A standard path to a given directory to import. This parameter is optional and defaults to null</p>\n\n<p><strong>options</strong>: The <code>options</code> object accepts these properties:</p>\n\n<blockquote>\n  <p><strong>locals</strong>: A user defined JS Object that will be made avialable to loaded modules</p>\n</blockquote>\n\n<blockquote>\n  <p><strong>packages</strong>: An arbitrary object or existing package structure from another require_tree instance that will serve as the basis for the current require_tree instance</p>\n</blockquote>\n\n<blockquote>\n  <p><strong>preserve_filenames</strong>: A boolean value instructing require_tree to preserve the filename in the package path structure. The default value is <code>false</code>\n<em>note</em>: This directive will be temporarily ignored and the filename used to name an unnamed function to support sloppy <code>module.exports = function() {...}</code> usage</p>\n</blockquote>\n\n<h2 id=\"methods\">Methods</h2>\n\n<p>The following <code>methods</code> are accessable from both the returned <code>package</code> structure and the <code>module.parent.exports</code></p>\n\n<p><strong>getTree(path)</strong></p>\n\n<p>Returns a given <code>package</code> and it's descendants. Accepts both hash and path syntax</p>\n\n<p><em>example:</em></p>\n\n<pre><code>// from application scope\ntree = require('require_tree').require_tree('lib');\nconsole.log( tree.require_tree.getTree('models') );\n\n// from loaded module\nconsole.log( module.parent.exports.getTree('models') );\n</code></pre>\n\n<p><strong>addTree(path)</strong></p>\n\n<p>Recursively loads a new directory structure into the <code>package</code> structure of the current scope</p>\n\n<p><em>example:</em></p>\n\n<pre><code>// from application scope\ntree = require('require_tree').require_tree('lib');\ntree.require_tree.addTree('otherLib');\n\n// from loaded module\nmodule.parent.exports.addTree('otherLib');\n</code></pre>\n\n<p><strong>extendTree(object)</strong></p>\n\n<p>Merges a given <code>package</code> and it's descendants with the existing <code>package</code> structure. </p>\n\n<p><em>example:</em></p>\n\n<pre><code>// from application scope\ntree = require('require_tree').require_tree('lib');\neTree = require('require_tree').require_tree('lib2');\ntree.require_tree.extendTree(eTree);\n\n// from loaded module\neTree = require('require_tree').require_tree('lib2');\nmodule.parent.exports.extendTree(eTree);\n</code></pre>\n\n<p><strong>removeTree(path)</strong></p>\n\n<p>Removes a given <code>package</code> and it's descendants from the <code>package</code> strucure. Accepts both hash and path syntax. </p>\n\n<p><em>Note</em>: This will not remove loaded Modules from the Module Cache.</p>\n\n<p><em>example:</em></p>\n\n<pre><code>// from application scope\ntree = require('require_tree').require_tree('lib');\ntree.require_tree.removeTree('models');\n\n// from loaded module\nmodule.parent.exports.removeTree('models');\n</code></pre>\n\n<p><strong>on(name, callback, context)</strong></p>\n\n<p>Adds an event handler for a given event</p>\n\n<p><em>example:</em></p>\n\n<pre><code>// -- will print contents of package to console when loading has completed\n(rTree = require('require_tree')).on( 'completed', function(data) {\n\tconsole.log(data);\n});\n\t\nrTree.require_tree('./lib');  \n</code></pre>\n\n<p><strong>off(name, callback, context)</strong></p>\n\n<p>Removes an event handler for a given event</p>\n\n<p><em>example:</em></p>\n\n<pre><code>\n(rTree = require('require_tree')).on( 'completed', function(data) {\n\t// -- will remove the event handler for further completed events.\n\tdata.require_tree.off('completed');\n\tconsole.log(data);\n});\n\t\nrTree.require_tree('./lib');  \n</code></pre>\n\n<p><strong>trigger(name, …)</strong></p>\n\n<p>Dispatches an event to all listeners</p>\n\n<p><em>example:</em></p>\n\n<pre><code>\n(rTree = require('require_tree')).on( 'myEvent', function(data) {\n\tconsole.log(data);\n});\n\n// -- calling trigger will cause the above listener to capture and event\nrTree.trigger('myEvent', {data:\"hello world\"});\n</code></pre>\n\n<h2 id=\"events\">Events</h2>\n<p>Event listeners may be added and removed using the <code>on</code> and <code>off</code> methods listed above\n the following events are dispatched by require_tree</p>\n\n<p><strong>completed</strong></p>\n\n<p>Triggered when <code>require_tree</code> has been called directly, passes package structure as it’s data payload</p>\n\n<p><strong>changed</strong></p>\n\n<p>Triggered when <code>addTree</code>, <code>removeTree</code> or <code>extendTree</code> have been called with the following payload:</p>\n\n<blockquote>\n  <p><em>packages</em>: the complete package structure in it’s present state\n<em>added</em>: If present, will contain the tree that has been added. Passed on addTree or extendTree operations\n<em>removed</em>: If present will contain the tree that has been removed. Only passed on removeTree operations</p>\n</blockquote>\n\n<h2 id=\"passing-data\">Passing Data</h2>\n\n<p>By passing a JS Object to the <code>locals</code> param of the<code>options</code> object, you can set that Object for access from <code>module.parent.exports.locals</code> in your loaded Module's scope.</p>\n\n<p><em>index.js:</em></p>\n\n<pre><code>var myMods = require_tree(\"lib\", {locals:{\"myArray\":[1,2,3,4]}});\n</code></pre>\n\n<p><em>lib/myMod.js:</em></p>\n\n<pre><code>var passedArray = module.parent.exports.locals.myArray;\nconsole.log(passedArray);\n</code></pre>\n\n<h2 id=\"nesting-requiretree-calls\">Nesting <code>require_tree</code> Calls</h2>\n\n<p>Making nested <code>require_tree</code> calls from within loaded Modules will create a new <code>require_tree</code> instance and Module Scope with a new package structure.\nUse the <code>packages</code> params of the <code>options</code> argument to pass in an exising object or <code>package</code> structure to <code>inherit</code> from. </p>\n\n<p><em>example:</em></p>\n\n<pre><code>(function(global)\n{\n\t// use require_tree to load a structure into a new scope\n\t// note that we pass in the packages object in the options for the new sub-tree\n\tglobal.config = require('require_tree').require_tree( '../subtree', {packages:{module.parent.exports.getPath('.')}});\n\t\n\t// our new tree will have inherited the parent require_tree packages\n\tconsole.log( global.config );\n})(exports);\n</code></pre>\n\n<h2 id=\"building-data-structures\">Building Data Structures</h2>\n\n<p><code>require_tree</code> allows you to import JSON documents and treats each index file as a root element.\nThis functionality allows you to create multiple index and data files to selectively build complex JSON data sets from static files.</p>\n\n<pre><code>- conf/\n\t- condition_1/\n\t\t- index.js\n\t- condition_2/\n\t\t- index.js\n- lib/\n\t- config.js\n- index.js\n</code></pre>\n\n<p>In the above diagram, we see a <code>configure.js</code> file and a <code>conf</code> structure.\nThe intent here is to have build a config file based on the user environment much as we would build an application config using a <code>configure</code> script</p>\n\n<p><em>lib/config.js</em></p>\n\n<pre><code>(function(global)\n{\n\t// attempt to get passed data from locals Object\n\tvar conditionValue = module.parent.exports.locals.condition || 1;\n\t// use require_tree to load a given structure into the current scope\n\tmodule.parent.exports.addTree( '../conf/condition_' +  conditionValue);\n})(exports);\n</code></pre>\n\n<p><em>index.js:</em></p>\n\n<pre><code>config = require_tree(\"lib\", {locals:{\"condition\":2}});\n\n// config will now contain the dynmically generated JS object structure\nconsole.log(config);\n</code></pre>\n\n<h2 id=\"accessing-the-package-structure\">Accessing the Package Structure</h2>\n\n<p>While <code>require_tree</code> returns the loaded package Structure to the caller, it can be very useful to be aware of the Package Structure from within a loaded module\n<code>require_tree</code> exports the packages as <code>exports.packages</code> and includes a <code>require_tree</code> package containing the exported methods listed in the<code>Methods</code> section above. </p>\n\n<h3 id=\"from-the-application-scope\">From the Application Scope</h3>\n\n<p><em>example:</em></p>\n\n<pre><code>var tree = require('require_tree').require_tree('path/to/dir');\n\n// using the `module.parent.exports.getTree` method\nvar otherObjectRef = tree.getTree('path.to.other.Object');\nthis.myRefInstance = new otherObjectRef();\n\n// add another directory structure to the current package\ntree.addTree('path/to/new/dir');\n// access the new tree\nconsole.log( tree.getTree('dir') );\n\n// remove a directory structure to the current package\ntree.removeTree('dir/subtree');\n// access the updated tree\nconsole.log( tree.getTree('dir') );\n\n// remove a directory structure to the current package\ntree.extendTree({dir:{newSubTree:{val1:\"value1\", val2:\"value2\"}}});\n// tree 'dir' will now have 'newSubTree' nested\nconsole.log( tree.getTree('dir') );\n</code></pre>\n\n<h3 id=\"from-loaded-modules\">From Loaded Modules</h3>\n\n<p><em>example:</em></p>\n\n<pre><code>(function(global)\n{\n\t// using the `module.parent.exports.getTree` method\n\tvar otherObjectRef = module.parent.exports.getTree('path.to.other.Object');\n\tglobal.myModule = function() {\n\t\tthis.myRefInstance = new otherObjectRef();\n\t}\n\t\n\t// add another directory structure to the current package\n\tmodule.parent.exports.addTree('path/to/new/dir');\n\t// access the new tree\n\tconsole.log( module.parent.exports.getTree('dir') )\n\t\n\t// remove a directory structure to the current package\n\tmodule.parent.exports.removeTree('dir/subtree');\n\t// access the updated tree\n\tconsole.log( module.parent.exports.getTree('dir') );\n\n\t// remove a directory structure to the current package\n\tmodule.parent.exports.extendTree({dir:{newSubTree:{val1:\"value1\", val2:\"value2\"}}});\n\t// tree 'dir' will now have 'newSubTree' nested\n\tconsole.log( module.parent.exports.getTree('dir') );\n})(exports)\n\n</code></pre>\n\n<h2 id=\"what-next\">What Next?</h2>\n\n<p>With recursive Module loading the ability to pass data and to create programmaticly defined structures on the fly, it seems only logical to add in module defined flow control and introspection,\nHowever, what those would mean for performance, usability and whether or not such features are appropriate for a module loader need some mulling over. So feel free to chime in with ideas, suggestions or pull requests.</p>\n<!-- === end markdown block ===================================================== -->\n",
  "readmeFilename": "README.html",
  "bugs": {
    "url": "https://github.com/vancarney/require_tree/issues"
  },
  "_id": "require_tree@0.6.5",
  "dist": {
    "shasum": "96593eb01d3251d5bd12a46fef6147f60735283f"
  },
  "_from": "require_tree@0.6.5",
  "_resolved": "https://registry.npmjs.org/require_tree/-/require_tree-0.6.5.tgz"
}
