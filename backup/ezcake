#!/usr/bin/env node
// Generated by CoffeeScript 1.4.0
'use strict';

var ezcake;

ezcake = (function() {

  function ezcake() {
    var _this = this;
    (this.cmd = require('commander')).version('version: #{@version}').option("-I, --ignore", "ignore global config file if defined in env.EZCAKE_HOME").option("-O, --no-override", "do not allow loaded configs to override each other").option("-l, --location <paths>", "set path(s) of config file location(s)", function(arg) {
      return arg.split(',');
    });
    this.fs = require('fs');
    this._ = require('underscore');
    this.version = '0.7';
    this.strings = {
      hash: '#',
      red: '\u001b[31m',
      green: '\u001b[32m',
      yellow: '\u001b[33m',
      reset: '\u001b[0m'
    };
    this.$path = this.fs.realpathSync('.');
    this.paths = {};
    this.callbacks = {};
    this.tasks = new String;
    this.helpers = new String;
    this.exts = [];
    this.cnf = {};
    this._defaults = [];
    this.uConfigured = {
      tasks: [],
      commands: [],
      modules: [],
      paths: {}
    };
    this.uObjects = {
      modules: {},
      commands: {},
      tasks: {},
      helpers: {},
      headers: {}
    };
    this._.each({
      "headers": {},
      "helpers": {},
      "commands": {},
      "modules": {},
      "tasks": {},
      "configurations": {}
    }, function(v, k) {
      _this["" + k] = {};
      return _this["add" + (k.charAt(0).toUpperCase()) + (k.substring(1, k.length - 1))] = function(name, o) {
        var idx;
        if ((idx = _this._defaults.indexOf(name)) >= 0) {
          _this._defaults.splice(idx, 1);
        }
        return _this["" + k][name] = o;
      };
    });
    this.applyDefinitions();
    this._defaults = this._.keys(this._.extend({}, this.modules, this.commands, this.tasks, this.helpers, this.headers));
    this.preprocessArgs();
    if ((this.$home = process.env.EZCAKE_HOME) !== void 0 && !this.cmd.ignore) {
      this.loadConfig("" + this.$home + "/ezcake.json");
    }
    if (this.cmd.location) {
      this._.each(this.cmd.location, function(l) {
        return _this.loadConfig(l);
      });
    }
    this.processArgs();
    if (process.argv[1].split('/').pop() === 'ezcake') {
      switch (this.command) {
        case "create":
        case "c":
          this.onCreate();
          break;
        case "init":
        case "i":
          this.onInit();
          break;
        default:
          this.cmd.usage("<command> [options]\n\n  where <command> is one of:\n    create, init\n    \n  ezcake <command> -h     quick help on <command>").parse(process.argv);
          process.exit;
      }
      this.cmd.usage(this.usage);
      if (this.configuration === "-h") {
        this.configuration = null;
      }
      if (this.configuration) {
        this.processConfiguration();
      }
      this.getOpts();
      this.help();
      this.cmd.parse(process.argv);
      this.getDirectives();
      this.findCustomDirectives();
      this.createPaths();
      this.writeCakeFile();
      if (this.cmd.config) {
        this.writeConfig();
      }
      process.stdout.write("" + this.success + "\n");
      process.exit(0);
    }
  }

  ezcake.prototype.preprocessArgs = function() {
    var args,
      _this = this;
    args = [];
    this._.each(process.argv, function(v, k) {
      if ((v.match(/^(\-h|\-\-help)+$/)) === null) {
        return args.push(v);
      }
    });
    return this.cmd.parse(args);
  };

  ezcake.prototype.processArgs = function() {
    var _this = this;
    if (process.argv.length < 3) {
      return process.argv.push("-h");
    } else {
      return process.argv.forEach(function(val, index, commandModuleArray) {
        _this.commandModuleArray = commandModuleArray;
        if (index === 0) {
          return (_this.env = val);
        }
        if (index === 1) {
          return (_this.path = val);
        }
        if (index === 2 && (typeof _this.command === 'undefined') && !(val.match(/^\-/))) {
          return (_this.command = val);
        }
        if (index === 3 && (_this.command.match(/create|init/)) && !(val.match(/^\-/))) {
          return (_this.configuration = val);
        }
        if (index === 4 && (_this.command.match(/create/)) && !(val.match(/^\-/))) {
          return (_this.name = val);
        }
      });
    }
  };

  ezcake.prototype.loadConfig = function(p) {
    var data, f,
      _this = this;
    if (this.fs.existsSync(p)) {
      try {
        if (f = this.fs.readFileSync(p)) {
          data = JSON.parse(f);
        }
        return this._.each(data.definitions, function(v, k) {
          var func;
          if (typeof _this[func = "add" + (k.charAt(0).toUpperCase()) + (k.substring(1, k.length - 1))] === 'function') {
            return _this._.each(v, function(sV, sK) {
              if (sV.inherits) {
                if (_this[k][sV.inherits]) {
                  sV.options = _this._.extend(_this[k][sV.inherits], sV.options);
                } else {
                  _this.error("" + (k.substring(0, k.length - 1)) + " \"" + sV.inherits + "\" does not exist.");
                }
              }
              if (!(_this.cmd.override === false && _this[k][v.name])) {
                return _this[func](sV.name || ("" + (k.substring(0, k.length - 1)) + "_" + (mkGUID())), sV.options);
              }
            });
          }
        });
      } catch (e) {
        return this.error(e);
      }
    } else {
      return this.warn("config file " + p + " was not found");
    }
  };

  ezcake.prototype.onCreate = function() {
    this.usage = "create " + (this.configuration || '<type>') + " <name> [options]\n\n  Creates new " + (this.configuration || '<type>') + " configuration as directory <name> in current path";
    if (typeof this.configuration === 'undefined') {
      this.usage += "\n  Available types: " + ((this._.map(this.configurations, function(v, k, l) {
        return k;
      })).join(', '));
    }
    if (typeof this.name !== 'undefined') {
      this.$path += "/" + this.name;
    } else {
      process.argv.push('-h');
    }
    if (!this.fs.existsSync(this.$path)) {
      this.fs.mkdirSync(this.$path);
    }
    return this.success = "" + this.configuration + " created as " + this.name + "\n";
  };

  ezcake.prototype.onInit = function() {
    this.usage = "init " + (this.configuration || '<type>') + " [options]\n\n  Creates or Updates " + (this.configuration || '<type>') + " Cakefile in current Project Directory";
    if (typeof this.configuration === 'undefined') {
      this.usage += "\n  Available types: " + ((this._.map(this.configurations, function(v, k, l) {
        return k;
      })).join(', '));
    }
    return this.success = "Cakefile updated!\n";
  };

  ezcake.prototype.processConfiguration = function() {
    if (typeof (this.cnf = this.configurations[this.configuration]) !== 'undefined') {
      return this.cmd.option("-F, --no-config", "Do not create ezcake config file");
    } else {
      return process.argv.push("-h");
    }
  };

  ezcake.prototype.getOpts = function() {
    var _this = this;
    return this._.each((this.commandModuleArr = [].concat(this.cnf.modules, this.cnf.commands)), function(v, k) {
      var t;
      if ((t = _this.modules[v] || _this.commands[v]) !== void 0) {
        _this.cmd.option(t.command[0], t.command[1]);
        if ((_this._.indexOf(t.command[1])) > -1 || process.argv[process.argv.length - 1].match(new RegExp("[" + (t.command[0].charAt(1)) + "]+"))) {
          if (typeof t.setFlag !== 'undefined' && (t.setFlag != null)) {
            return process.argv.push(t.setFlag);
          }
        }
      } else {
        return _this.error("" + v + " was not defined");
      }
    });
  };

  ezcake.prototype.getDirectives = function() {
    var _this = this;
    this._.each(this.commandModuleArr, function(v, k) {
      var setpath, t;
      if (typeof _this.cmd[v] !== 'undefined' && _this.cmd[v]) {
        if (typeof _this.modules[v] !== 'undefined' && ((t = _this.modules[v]) != null)) {
          _this.uConfigured.modules.push(v);
        } else if (typeof _this.commands[v] !== 'undefined' && ((t = _this.commands[v]) != null)) {
          _this.uConfigured.commands.push(v);
        } else {
          _this.error("" + v + " was not defined");
        }
        if (typeof t.callback !== 'undefined') {
          _this.callbacks["on" + (t.callback.charAt(0).toUpperCase()) + (t.callback.substring(1, t.callback.length))] = "" + _this.strings.hash + " Callback From '" + v + "'\n" + t.callback + "=()->\n";
        }
        switch (Object.prototype.toString.call(t.paths)) {
          case '[object Object]':
            setpath = t.paths;
            break;
          case '[object Array]':
            setpath = JSON.parse("{\"" + v + "\":" + (JSON.stringify(t.paths)) + "}");
            break;
          case 'undefined':
            break;
          default:
            setpath = void 0;
        }
        if (typeof t.paths !== 'undefined') {
          return _this.paths = _this._.extend(_this.paths, setpath);
        }
      }
    });
    this.paths = this._.extend(this.paths, this.cnf.paths);
    this.modules = this._.pick(this.modules, this.uConfigured.modules);
    return this.commands = this._.pick(this.commands, this.uConfigured.commands);
  };

  ezcake.prototype.findCustomDirectives = function() {
    var kind, name, obj, _i, _len, _ref, _results;
    _ref = this._.difference(this._.extend({}, this._.keys(this.modules, this._.keys(this.commands, this._.keys(this.tasks, this._.keys(this.helpers, this._.keys(this.headers)))))), this._defaults);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = ["commands", "modules", "tasks", "helpers", "headers"];
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          kind = _ref1[_j];
          if ((obj = this[kind][name]) != null) {
            _results1.push(this.uObjects[kind][name] = obj);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  ezcake.prototype.getExts = function() {
    var exts,
      _this = this;
    exts = [];
    this._.each(this.modules, function(v, k) {
      if (v.ext != null) {
        return exts.push(v.ext);
      }
    });
    return exts.join('|');
  };

  ezcake.prototype.getPaths = function() {
    var f,
      _this = this;
    f = [];
    this._.each(this.paths, function(v, k) {
      if (typeof _this.cmd[v] === 'undefined' || !_this.cmd[v]) {
        _this.uConfigured.paths[k] = v;
        return f = f.concat(_this._.flatten(_this._.toArray(v)));
      }
    });
    return f;
  };

  ezcake.prototype.createPaths = function() {
    var _this = this;
    return this._.each(["", "src"].concat(this.getPaths()), function(v, k) {
      var p, path;
      path = "" + _this.$path;
      return _this._.each((p = v.split('/')), function(i, j) {
        if (!_this.fs.existsSync(path = "" + path + "/" + i)) {
          return _this.fs.mkdirSync(path);
        }
      });
    });
  };

  ezcake.prototype.getHeaders = function() {
    var _this = this;
    return this._.map(this.headers, function(v, k) {
      if (v.require) {
        return "require '" + v.require + "'";
      }
      if (v.block) {
        return "" + v.block;
      }
    }).join('\n');
  };

  ezcake.prototype.getCallbacks = function() {
    var _this = this;
    this._.each(this.callbacks, function(cb, cn) {
      return _this._.each(_this._.pluck(_this._.extend({}, _this.modules, _this.commands), cn), function(cV, cK) {
        if (typeof cV !== 'undefined') {
          return _this.callbacks[cn] = new String(_this.callbacks[cn] + cV);
        }
      });
    });
    return (this._.values(this.callbacks)).join('\n');
  };

  ezcake.prototype.getHelpers = function() {
    var helpers,
      _this = this;
    helpers = "";
    this._.each(this.helpers, function(v, k, l) {
      return helpers += "" + _this.strings.hash + " " + k + " helper method\n" + k + " = " + v.method;
    });
    return helpers;
  };

  ezcake.prototype.getTasks = function() {
    var tasks,
      _this = this;
    tasks = "";
    if (typeof this.cnf.tasks !== 'undefined') {
      this._.each(this.cnf.tasks, function(v, k, l) {
        var handlerName, handlers;
        if (_this.tasks[v] != null) {
          _this.uConfigured.tasks.push(v);
          handlerName = "on" + (v.charAt(0).toUpperCase()) + (v.slice(1));
          handlers = "" + (_this.tasks[v].handler || new String);
          _this._.each(_this.uConfigured.modules, function(v, k) {
            if ((_this.modules[v] != null) && _this.modules[v][handlerName]) {
              handlers += "" + _this.strings.hash + " From Module '" + v + "'\n  ";
            }
            if ((_this.modules[v] != null) && _this.modules[v][handlerName]) {
              return handlers += "" + _this.modules[v][handlerName] + "\n  ";
            }
          });
          return tasks += "" + _this.strings.hash + " " + _this.strings.hash + _this.strings.hash + " *" + v + "*\n" + _this.strings.hash + " " + _this.tasks[v].description + "\ntask '" + v + "', '" + _this.tasks[v].description + "', (" + (_this.tasks[v].args || new String) + ")-> " + (v.replace(/:/g, '_')) + " -> log ':)', green\n" + (v.replace(/:/g, '_')) + " = (" + (_this.tasks[v].args || new String) + ")->\n  " + handlers + "\n\n";
        }
      });
      return tasks;
    }
  };

  ezcake.prototype.writeCakeFile = function() {
    var s;
    s = "" + this.strings.hash + " Another Cakefile made with love by ezcake v" + this.version + "\n" + (this.getHeaders()) + "\npaths=" + (JSON.stringify(this.cnf.paths)) + "\nexts='" + (this.getExts()) + "'\n" + this.strings.hash + " Begin Callback Handlers\n" + (this.getCallbacks()) + "\n" + this.strings.hash + " Begin Tasks\n" + (this.getTasks()) + "\n" + this.strings.hash + " Begin Helpers\n" + (this.getHelpers());
    try {
      return this.fs.writeFileSync("" + this.$path + "/Cakefile", s);
    } catch (e) {
      return this.error(e);
    }
  };

  ezcake.prototype.writeConfig = function() {
    try {
      return this.fs.writeFileSync("" + this.$path + "/ezcake.json", "" + (JSON.stringify({
        'definitions': this.uObjects,
        'configuration': this.uConfigured
      }, null, 2)));
    } catch (e) {
      return this.error("" + e);
    }
  };

  ezcake.prototype.help = function() {
    var idx;
    if ((idx = process.argv.indexOf('-h')) > -1) {
      return process.argv.splice(2, idx - 2);
    }
  };

  ezcake.prototype.mkGUID = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r;
      return ((r = Math.random() * 16 | 0) > -1 && c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  ezcake.prototype.log = function(m) {
    return process.stdout.write("" + m + "\n");
  };

  ezcake.prototype.warn = function(m) {
    return process.stdout.write("" + this.strings.yellow + "Warning: " + m + this.strings.reset + "\n");
  };

  ezcake.prototype.error = function(m) {
    process.stderr.write("" + this.strings.red + "Error: " + m + this.strings.reset + "\n");
    return process.exit(1);
  };

  ezcake.prototype.applyDefinitions = function() {
    this.addHeader("fs", {
      block: "fs = require 'fs'"
    });
    this.addHeader("util", {
      block: "{print} = require 'util'"
    });
    this.addHeader("child_process", {
      block: "{spawn, exec}=require 'child_process'"
    });
    this.addHeader("which", {
      block: "try\n  which = require('which').sync\ncatch err\n  if process.platform.match(/^win/)?\n    console.warn 'The which module is required for windows. try \"npm install which\"'\n  which = null"
    });
    this.addHeader("colors", {
      block: "" + this.strings.hash + " ANSI Terminal Colors\nbold = '\x1b[0;1m'\ngreen = '\x1b[0;32m'\nreset = '\x1b[0m'\nred = '\x1b[0;31m'"
    });
    this.addTask("build", {
      description: "Compiles Sources"
    });
    this.addTask("build:release", {
      description: "Copy contents of debug to web release folder and minify",
      paths: ["debug", "www"],
      handler: "exec \"cp -r " + this.strings.hash + "{paths.release[0]} " + this.strings.hash + "{paths.release[1]}\" if paths? and paths.release\n  minify()"
    });
    this.addTask("watch", {
      description: "watch project src folders and build on change",
      handler: "exec \"supervisor -e '\"+exts+\"' -n exit -q -w src -x 'cake' build\" "
    });
    this.addTask("docs", {
      description: "Generate Documentation",
      paths: ["docs"]
    });
    this.addTask("minify", {
      description: "Minify Generated JS and HTML"
    });
    this.addTask("readme", {
      description: "Generate ReadMe HTML from Markdown"
    });
    this.addTask("test", {
      description: "Runs your test suite.",
      args: ["options=[]", "callback"],
      paths: ["tests"]
    });
    this.addTask("clean", {
      description: "Cleans up generated js paths",
      handler: "  try\n    for file in paths.coffee\n      unless unlinkIfCoffeeFile file\n        walk file, (err, results) ->\n          for f in results\n            unlinkIfCoffeeFile f\n\n    callback?()\n  catch err\n    console.error red+err"
    });
    this.addTask("up2date", {
      description: "installs/updates referenced NPMs and Gems",
      handler: ""
    });
    this.addModule("coffee", {
      ext: "coffee",
      exec: "npm",
      name: "coffee-script",
      options: "-g",
      paths: [".", "src/coffee"],
      callback: "coffeeCallback",
      onBuild: "launch 'coffee', (['-c', '-b', '-l', '-o' ].concat paths.coffee), coffeeCallback()",
      command: ['-0, --no-coffee', 'don\'t use coffee-script (js only)']
    });
    this.addModule("scss", {
      ext: "scss",
      exec: "gem",
      name: "sass",
      paths: ["src/scss", "www/css"],
      callback: "scssCallback",
      onBuild: "launch 'sass', paths.sass, scssCallback()",
      command: ['-s, --scss', 'use scss (sass) instead of less (requires ruby gems)'],
      setFlag: "-L"
    });
    this.addModule("less", {
      ext: "less",
      exec: "npm",
      name: "less",
      options: "-g",
      callback: "lessCallback",
      paths: ["src/less", "www/css"],
      onBuild: "launch 'lessc', paths.less, lessCallback()",
      command: ['-L, --no-less', 'do not use less']
    });
    this.addModule("jade", {
      ext: "jade",
      exec: "npm",
      name: "jade",
      options: "-g",
      paths: ["src/jade", "www", "src/jade/templates", "src/jade/includes"],
      onBuild: "exec \"jade " + this.strings.hash + "{paths.jade[2]} -v --pretty --out " + this.strings.hash + "{paths.jade[1]}\" ",
      command: ['-J, --no-jade', 'do not use Jade templates']
    });
    this.addModule("jst", {
      ext: "js",
      paths: ["src/jst", "www/js"],
      onBuild: "exec 'jst -t dust '+paths.jst[0]+'>'+paths.jst[1]",
      allowed: ['dust', 'mustache', 'handlebars', 'hogan'],
      command: ['-t, --jst <engine>', 'use javascript template engine [dust,mustache,handlebars,hogan]', String, 'dust']
    });
    this.addModule("jquery", {
      exec: "npm",
      name: "jquery",
      options: "-g",
      command: ['-q, --jquery', 'use jQuery for node']
    });
    this.addModule("mocha", {
      exec: "npm",
      name: "mocha",
      options: "-g",
      paths: ['test'],
      command: ['-M, --no-mocha', 'disable mocha support'],
      onTest: "if moduleExists('mocha')\n    if typeof options is 'function'\n      callback = options\n      options = []\n    " + this.strings.hash + " add coffee directive\n    options.push '--compilers'\n    options.push 'coffee:coffee-script'\n    \n    launch 'mocha', options, callback"
    });
    this.addModule("chai", {
      exec: "npm",
      name: "chai",
      options: "-g",
      paths: ['test'],
      command: ['-C, --no-chai', 'disable chai support']
    });
    this.addModule("docco", {
      exec: "npm",
      name: "docco",
      options: "-g",
      command: ['-D, --no-docco', 'disable docco support'],
      callback: "doccoCallback",
      onDocs: "if moduleExists 'docco' && paths? && paths.coffee\n    walk paths.coffee[0], (err, paths) ->\n      try\n        launch 'docco', paths, doccoCallback()\n      catch e\n        error e"
    });
    this.addModule("markdown", {
      exec: "gem",
      name: "markdown",
      command: ['-k, --markdown', 'enable markdown parsing (requires ruby gems, Python and PEAK)'],
      onReadme: "-> launch 'markdown'"
    });
    this.addModule("compass", {
      ext: "scss",
      exec: "gem",
      name: "compass",
      callback: "compassCallback",
      onBuild: "launch 'compass', ['compile', '--sass-dir=" + this.strings.hash + "{paths.scss[1]}', '--css-dir=" + this.strings.hash + "{paths.scss[0]}'], callback",
      command: ['-c, --compass', 'use Compass for SCSS (requires ruby gems)']
    });
    this.addModule("uglify", {
      exec: "npm",
      name: "uglifyjs",
      options: "-g",
      command: ["-U, --no-uglify", "do not use uglifyjs"],
      callback: "minifyCallback",
      onMinify: "" + this.strings.hash + " minify js and html paths\n  if paths? and paths.uglify?\n    walk \"" + this.strings.hash + "{paths.uglify[0]}\", (err, results) =>\n      for file in results\n        continue if file.match /\.min\.js+$/\n        launch 'uglifyjs', if file.match /\.js+$/ then ['--output', \"dir/" + this.strings.hash + "{file.replace /\.js+$/,'.min.js'}\", file] else ['--output', \"dir/" + this.strings.hash + "{file}\", file]"
    });
    this.addModule("stitch", {
      exec: "npm",
      name: "stitch",
      options: "-g",
      require: true,
      command: ["-s, --stitch", "use Stitch JS packager"],
      paths: ["www/js/lib", "www/js/vendor"],
      onMinify: "if paths.stitch\n  try\n    (stitch.createPackage\n      paths:paths.stitch\n    ).compile (e, src)->\n      fs.writeFile 'package.js', src, (e)->\n      throw e if (e) "
    });
    this.addCommand('assets', {
      command: ['-A, --no-assets', 'disable static asset copying from src directory'],
      onBuild: "exec \"cp -r (" + this.strings.hash + "{paths.assets[0]}) (" + this.strings.hash + "{paths.assets[1]} )\" if paths? and paths.assets?"
    });
    this.addCommand("bin", {
      paths: ['bin', 'src/coffee/bin'],
      command: ['-b, --bin', 'create \'bin\' output and source directories (useful for nodejs commandline apps)'],
      onCoffeeCallback: "" + this.strings.hash + " try to move bin folder and cat shabang onto all files in ./bin, deleting original .js files when dones\n  try\n    exec \"mv " + this.strings.hash + "{paths.coffee[0]}/" + this.strings.hash + "{paths.bin[0]}/* " + this.strings.hash + "{paths.bin[0]}\" if paths.coffee?\n    if (files = fs.readdirSync (\"" + this.strings.hash + "{paths.coffee[0]}/" + this.strings.hash + "{paths.bin[0]}\")) != null and files.length\n      for file in files\n        if file.match /\.js+$/\n          out = \"" + this.strings.hash + "{paths.bin[0]}/" + this.strings.hash + "{file}\".split('.').shift()\n          exec \"echo '" + this.strings.hash + "!/usr/bin/env node' | cat - " + this.strings.hash + "{paths.bin[0]}/" + this.strings.hash + "{file} > " + this.strings.hash + "{out}\", =>\n            fs.unlink \"" + this.strings.hash + "{paths.bin[0]}/" + this.strings.hash + "{file}\"\n  catch e\n    error e"
    });
    this.addCommand("lib", {
      paths: {
        coffee: ["lib", "src/coffee"]
      },
      command: ['-L, --no-lib', 'do not create \'lib\' output and source directories']
    });
    this.addCommand("force", {
      command: ['-f, --force', 'force overwrite of default configurations']
    });
    this.addCommand("noJST", {
      command: ['-T, --no-jst', 'disable javascript template parsing']
    });
    this.addHelper("launch", {
      method: "(cmd, options=[], callback) ->\n  cmd = which(cmd) if which\n  app = spawn cmd, options\n  app.stdout.pipe(process.stdout)\n  app.stderr.pipe(process.stderr)\n  app.on 'exit', (status) -> callback?() if status is 0"
    });
    this.addHelper("log", {
      method: "(message, color, explanation) -> \n  console.log color+message+reset+(explanation or '')"
    });
    this.addHelper("moduleExists", {
      method: "(name) ->\n  try \n    require name \n  catch err \n    error name+ 'required: npm install '+name, red\n    false"
    });
    this.addHelper("unlinkIfCoffeeFile", {
      method: "(file) ->\n  if file.match /\.coffee$/\n    fs.unlink file.replace(/\.coffee$/, '.js')\n    true\n  else false"
    });
    this.addHelper("walk", {
      method: "(dir, done) ->\n  " + this.strings.hash + " Directory Traversal\n  results = []\n  fs.readdir dir, (err, list) =>\n    return done(err, []) if err\n    pending = list.length\n    return done(null, results) unless pending\n    for name in list\n      file = dir+'/'+name\n      try\n        stat = fs.statSync file\n      catch err\n        stat = null\n      if stat?.isDirectory()\n        walk file, (err, res) =>\n          results.push name for name in res\n          done(null, results) unless --pending\n      else\n        results.push file\n        done(null, results) unless --pending\n\n\n"
    });
    this.addConfiguration("web", {
      commands: ['assets', 'noJST'],
      modules: ['coffee', 'jade', 'less', 'scss', 'compass', 'jst', 'docco', 'mocha', 'uglify', 'markdown'],
      tasks: ["build", "build:release", "watch", "minify", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        release: ['debug', 'www'],
        assets: ["src/assets", "debug"],
        coffee: ["debug/js", "src/coffee"],
        uglify: ['www'],
        less: ['src/less', 'debug/css'],
        jade: ["src/jade", "debug", "src/jade/templates", "src/jade/include"],
        jst: ["src/jst", "debug/js"]
      }
    });
    this.addConfiguration("plugin", {
      commands: ['assets', 'lib'],
      modules: ['coffee', 'jade', 'less', 'scss', 'compass', 'docco', 'mocha', 'uglify', 'markdown'],
      tasks: ["build", "watch", "minify", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        demo: ["demo"],
        uglify: ['lib'],
        assets: ["src/assets", "lib"],
        coffee: ["lib", "src/coffee"],
        jade: ["src/jade", "demo", "src/jade/templates", "src/jade/include"]
      }
    });
    this.addConfiguration("node-npm", {
      commands: ['lib', 'bin'],
      modules: ['coffee', 'docco', 'mocha', 'markdown'],
      tasks: ["build", "watch", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        coffee: [".", "src/coffee"],
        bin: ["src/coffee/newbin", "newbin"]
      }
    });
    this.addConfiguration("npm", this.configurations['node-npm']);
    this.addConfiguration("node-app", {
      commands: ['lib'],
      modules: ['coffee', 'docco', 'mocha', 'markdown'],
      tasks: ["build", "watch", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        coffee: ["src/coffee", "."]
      }
    });
    return this.addConfiguration("app", this.configurations['node-app']);
  };

  return ezcake;

})();

(typeof exports !== "undefined" && exports !== null ? exports : window).EzCake = ezcake;

if (process && process.argv && process.argv[1].split('/').pop() === 'ezcake') {
  new ezcake;
}
