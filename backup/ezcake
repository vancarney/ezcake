## EzCake Cake File Generator
#### (c)2012-2013 Van Carney
class ezcake
  # requires [Node.js FS](http://nodejs.org/api/fs.html)
  fs: require 'fs'
  # requires [UnderscoreJS](https://github.com/documentcloud/underscore)
  _: require 'underscore'
  async: require 'async'
  require_tree: require 'require_tree'
  version: '0.0.1'
  process: process
  strings:
    hash:   '#'
    red:    '\u001b[31m'
    green:  '\u001b[32m'
    yellow: '\u001b[33m'
    reset:  '\u001b[0m'
  paths:{}
  name: ""
  callbacks:{}
  tasks: new String
  helpers: new String
  exts: []
  cnf: {}
  _defaults: []
  # set up our conf object for ezcake.jason
  uConfigured: 
    tasks:[]
    commands:[]
    modules:[]
    paths:{}
  uObjects:
    modules:{}
    commands:{}
    tasks:{}
    helpers:{}
    declarations:{} 
  #### Constructor Method
  constructor:()->
    # initialize methods to populate our configuration deirctive objects with
    @_.each {"declarations":{},"helpers":{},"commands":{},"modules":{},"tasks":{},"configurations":{}}, (v,k)=>
      @["#{k}"] = {}
      @["add#{k.charAt(0).toUpperCase()}#{k.substring 1, k.length-1}"] = (o)=>
        # remove name from _defaults list if exists (this flags the new object as Custom
        @_defaults.splice idx, 1 if (idx = @_defaults.indexOf o.name) >= 0
        # add the object to the appropriate container (command, module ... etc)
        @["#{k}"][o.name] = o 
      
    # requires [Commander.js](https://github.com/visionmedia/commander.js)
    (@cmd = require 'commander').version( 'version: #{@version}'
    # set Option 'Ignore'
    ).option( "-I, --ignore", "ignore global config file if defined in env.EZCAKE_HOME"
    # set Option 'No Override'
    ).option( "-O, --no-override", "do not allow loaded configs to override each other"
    # set Option 'Location'
    ).option  "-l, --location <paths>", "set path(s) of config file location(s)", (arg)->arg.split ','

    @async.series [
      ((cb)=>
        # our actual path for reference use
        @fs.realpath '.', false, (e, path)=>
          @error e if e?
          @$path = path
          cb null, "ok"
      ),
      # load our default definitions
      ((cb)=>
        @applyDefinitions cb
      ),
      # We preprocess our args because we need to detect things such as `config` loading preferences
      ((cb)=>
        # populate _defaults with our existing default configurations
        @_defaults = @_.keys @_.extend {}, @modules, @commands, @tasks, @helpers, @declarations
        @preprocessArgs cb
      ),
      # load the global config file if `EZCAKE_HOME` is defined and we aren't ignoring
      ((cb)=>
        @loadConfig "#{@$home}/ezcake.json" if (@$home = @process.env.EZCAKE_HOME) != undefined and !@cmd.ignore
        # if the user has passed a location in the commandline, we will load that location now
        if @cmd.location
          @_.each @cmd.location, (l)=>@loadConfig l
        cb null, "ok"
      ),
      # Now that all `configs` are loaded, we can do process the complete options set
      ((cb)=>
        @processArgs()
        cb null, "ok"
      ),
      ((cb)=>
        # we do this check to avoid testing conflicts
        if @process.argv[1].split('/').pop() == 'ezcake'
          switch @command
            when "create", "c" then @onCreate()
            when "init", "i" then @onInit()
            else
              @cmd.usage( """
              <command> [options]
              
                where <command> is one of:
                  create, init
                  
                ezcake <command> -h     quick help on <command>
              """).parse @process.argv
              @process.exit
        @cmd.usage @usage
        cb null, "ok"
      ),
      ((cb)=>
        # unset @configuration if it is help flag
        @configuration = null if @configuration == "-h"
        @processConfiguration() if @configuration
        @getOpts()
        cb null
      ),
      # check for help flag
      ((cb)=>
        @help()
        cb null
      ),
      ((cb)=>
        # finally parse input from argv
        @cmd.parse @process.argv
        cb null
      ),
      # gather the user selected elements
      ((cb)=>@getDirectives cb),
      ((cb)=>@findCustomDirectives cb),
      # create paths
      ((cb)=>@createPaths cb),
      # attempt to write the Cakefile
      ((cb)=>@writeCakeFile cb),
      # attempt to write the current config to ezcake.json unless told not to
      ((cb)=>
        if @cmd.config
          @writeConfig cb
        else
          cb null
      )], (err,r)=>
        # If we have gotten here without error, let's write our success message
        @log "#{@success}\n"
        # ... and close up shop
        @process.exit 0
        
  preprocessArgs:(callback)->
    args = []
    @_.each @process.argv, (v,k)=>args.push v if (v.match /^(\-h|\-\-help)+$/) == null
    @cmd.parse args
    callback null
  createDir:(path, callback)->
    @fs.exists "#{path}", ((x)=>
      if !x
        @fs.mkdir "#{path}", (e)=>
          callback e || null
      else
        callback null
    ) 
  #### void processArgs()
  # validate `process.argv` @commandModuleArray and set variables based on it's content
  processArgs:->
    # force help for invalid command format
    if @process.argv.length <3
      @process.argv.push "-h"
    else
      # we loop through argv and set some variables for reference
      @process.argv.forEach (val, index, @commandModuleArray)=>
        # `@env` tells us it's Node
        return (@env = val)           if index == 0
        # `@path` tells us our current working directory
        return (@path = val)          if index == 1
        # `@command` should be one of `create` or `init` or one of their aliases
        return (@command = val)       if index == 2 && (typeof @command == 'undefined') && !(val.match /^\-/)
        # `@configuration` should map to a valid `ezcake.json` configuration directive
        return (@configuration = val) if index == 3 && (@command.match /create|init/) && !(val.match /^\-/)
        # ``@name` is the directory name to be created and only applicable for `create`
        return (@name = val)          if index == 4 && (@command.match /create/) && !(val.match /^\-/)
  #### LoadConfig(path)
  # Loads Configuration at given path and processes it's Directives
  loadConfig: (p)->
    @fs.exists p, (bool)=>
      return @warn "config file #{p} was not found" if !bool
      # import data from file
      @fs.readFile p, (e,d)=>
        @error e if e?
        @processConfig JSON.parse d || {}
  processConfig: (data)->
    @_.each data, (v,k)=>
      # process valid directives
      if typeof @[func = "add#{k.charAt(0).toUpperCase()}#{k.substring 1, k.length-1}"] == 'function'
        for obj in v
          # check for inheritance
          if typeof obj['inherits'] != 'undefined'
            if (s=@[k][obj.inherits])
              # if we inheit, we `_.extend` that object
              obj = @_.extend {}, @[k][obj.inherits], obj
            else
              # we throw an error if we are told to extend something that does not exist
              @error "#{k.substring 0, k.length-1} \"#{sV.inherits}\" does not exist."
          # call the method handler for this type of directive
          @[func] obj if !((@cmd? and @cmd.override == false) and @[k][obj.name]) 
  #### onCreate
  onCreate:->
    @usage="""create #{@configuration or '<type>'} <name> [options]
    
      Creates new #{@configuration or '<type>'} configuration as directory <name> in current path
    """
    @usage += "\n  Available types: #{(@_.map @configurations, (v,k,l)->k).join ', '}" if typeof @configuration == 'undefined'
    if (typeof @name != 'undefined') then @$path +="/#{@name}" else @process.argv.push '-h'
    @fs.exists @$path, (bool)=>
      if !bool
        @fs.mkdir @$path, (e)=>
          @error e if e?
          @success = "#{@configuration} created as #{@name}\n"
  #### onInit
  onInit: ->
    @usage="""init #{@configuration or '<type>'} [options]
    
      Creates or Updates #{@configuration or '<type>'} Cakefile in current Project Directory
    """
    @usage += "\n  Available types: #{(@_.map @configurations, (v,k,l)->k).join ', '}" if typeof @configuration == 'undefined'
    @success = "Cakefile updated!\n"
  #### processConfiguration
  processConfiguration:->
    # process our configuration
    if typeof (@cnf=@configurations[@configuration]) != 'undefined'
      # add no-config to Commander options
      @cmd.option "-F, --no-config", "Do not create ezcake config file"
    else
      # if we got here we need help
      @process.argv.push "-h"
  getOpts:->
    @_.each (@commandModuleArr=[].concat @cnf.modules, @cnf.commands), (v,k)=>
      if (t = @modules[v] || @commands[v]) != undefined
        # load the command value into Commander
        @cmd.option t.command[0], t.command[1]
        if (@_.indexOf t.command[1]) > -1 || @process.argv[@process.argv.length - 1].match new RegExp "[#{t.command[0].charAt 1}]+"
          @process.argv.push t.setFlag if typeof t.setFlag != 'undefined' && t.setFlag?
      else
        @error "#{v} was not defined"
  hasRequired:()->
    has = @_.every @_.flatten(@_.pluck @uConfigured,  "required"), (val)=>
      (@_.find (@_.pluck @_.extend( {}, @declarations, @helpers, @uConfigured.modules), "name"), (n)=>
        n == val
      ) || false
    throw new Error "'#{val}' was required but not found" if not has
    true
  getDirectives:(callback)->
    @_.each @commandModuleArr, (v,k)=>
      # ensure the directive is defined and not disabled via arguments
      if typeof @cmd[v] != 'undefined' && @cmd[v]
        # test if the directive is a module
        if typeof @modules[v] != 'undefined' && (t = @modules[v])?
          @uConfigured.modules.push v
        # test if the directive is a command
        else if typeof @commands[v] != 'undefined' && (t = @commands[v])?
          @uConfigured.commands.push v
        # did not pass either test, throw an error and stop execution
        else
          callback "#{v} was not defined"
        # test for callback and create entry if found
        @callbacks["on#{t.callback.charAt(0).toUpperCase()}#{t.callback.substring 1,t.callback.length}"] = "#{@strings.hash} Callback From '#{v}'\n#{t.callback}=()->\n" if typeof t.callback != 'undefined'
        # handle any path setting defined in our current directive
        switch (Object.prototype.toString.call t.paths)
          when '[object Object]'
            setpath = t.paths
          when '[object Array]'
            setpath = JSON.parse "{\"#{v}\":#{JSON.stringify t.paths}}"
          when 'undefined'
            #-- do nothing 
          else
            setpath = undefined
            # @warn "paths parameter for '#{v}' must be of type Object or type Array, skipping setting for '#{v}.paths'"
        # add the current path to the aggregate paths object if defined
        @paths = @_.extend @paths, setpath if typeof t.paths != 'undefined'
    # set final paths object based on config overrides
    @paths = @_.extend @paths, @cnf.paths
    # filter modules
    @modules  = @_.pick  @modules, @uConfigured.modules
    # filter commands
    @commands = @_.pick @commands, @uConfigured.commands
    callback null
  findCustomDirectives:(callback)->
    for name in @_.difference (@_.extend {}, @_.keys @modules, @_.keys @commands, @_.keys @tasks, @_.keys @helpers, @_.keys @declarations), @_defaults
      for kind in ["commands","modules","tasks","helpers","declarations"]
        @uObjects[kind][name] = obj if (obj = @[kind][name])?
    callback null
  # returns an array all file extensions defined by our modules
  getExts:->
    @_.compact @_.pluck @modules, 'ext'
  getPaths:->
    f = []
    @_.each (@paths), (v,k)=>
      if typeof @cmd[v] == 'undefined' || !@cmd[v]
        @uConfigured.paths[k] = v
        f = f.concat @_.flatten @_.toArray v
    f
  # traverse configured paths and create directory hierarchy
  createPaths:(cb)->
    @async.each (["", "src"].concat @getPaths()), ((p,cb2)=>
      # reset our path to working dir
      path = "#{@$path}"
      arr = p.split '/'
      arr.splice -1,0,''
      # for each item in arr we append that to `path` and attempt to create it
      @async.each arr, ((item,cb3)=>@createDir (path="#{path.replace /\/$/, ''}/#{item}"), cb3), (e)=>cb2 null
    ), (e)=>cb null
  getDeclarations:->
    # concatenate in all declarations that are defined
    @_.map(@declarations, (v,k)=>
      return "#{@strings.hash} #{v.description || v.name + 'header'}\n#{v.body}" if v.body
    ).join '\n'
  getCallbacks:->
    @_.each @callbacks, (cb, cn)=>
      @_.each (@_.pluck (@_.extend {}, @modules, @commands), cn), (cV,cK)=>
        @callbacks[cn] = new String @callbacks[cn]+cV if typeof cV != 'undefined'
    (@_.values @callbacks).join '\n'
  getHelpers:->
    helpers = ""
    # loop through any defined Helpers
    @_.each @helpers, (v,k,l)=>
      helpers += """
      #{@strings.hash} #{v.description || k +"helper method"}
      #{k} = #{v.body}"""
    helpers
  getTasks:->
    tasks = ""
    # test for any defined Tasks
    if typeof @cnf.tasks != 'undefined'
      # Traverse Tasks Object
      @_.each @cnf.tasks, (v,k,l)=>
        if @tasks[v]?
          @uConfigured.tasks.push v
          handlerName = "on#{v.charAt(0).toUpperCase()}#{v.slice 1}"
          body = "#{@tasks[v].body || new String}"
          @_.each @uConfigured.commands, (v,k)=>
            if @commands[v].invocations?
              if (invocation = @_.where @commands[v].invocations, {call:handlerName}).length
                body += """
                #{@strings.hash} From Command '#{v}'
                  #{'# '+@commands[v].description}
                  #{invocation[0].body}\n  
                """
          @_.each @uConfigured.modules, (v,k)=>
            if @modules[v].invocations?
              if (invocation = @_.where @modules[v].invocations, {call:handlerName}).length
                body += """
                #{@strings.hash} From Module '#{v}'
                  #{'# '+@modules[v].description}
                  #{invocation[0].body}\n  
                """
          tasks += """
          #{@strings.hash} #{@strings.hash}#{@strings.hash} *#{v}*\n#{@strings.hash} #{@tasks[v].description}\ntask '#{v}', '#{@tasks[v].description}', (#{@tasks[v].args || new String})-> #{v.replace /:/g, '_'} -> log ':)', green
          #{v.replace /:/g, '_'} = (#{@tasks[v].args || new String})->
            #{body}
          \n"""
    tasks
  toJSON:->
    (
      declarations:@declarations
      helpers:@helpers
      commands:@commands
      modules:@modules
      tasks:@tasks
      configurations:@configurations
    )
  toString:->
    JSON.stringify @toJSON(), null, 2
  #### writeCakeFile
  writeCakeFile:(callback)->
    s = """#{@strings.hash} Another Cakefile made with love by ezcake v#{@version}
    #{@getDeclarations()}
    # paths object for module invocation reference
    paths=#{JSON.stringify @cnf.paths, null, 2}
    # file extensions for watching
    exts='#{@getExts().join '|'}'
    #{@strings.hash} Begin Callback Handlers
    #{@getCallbacks()}
    #{@strings.hash} Begin Tasks
    #{@getTasks()}
    #{@strings.hash} Begin Helpers
    #{@getHelpers()}"""
    @fs.writeFile "#{@$path}/Cakefile", s, null, (e)=> callback e
  #### writeCakeFile
  writeConfig:(callback)->
    @fs.writeFile "#{@$path}/ezcake.json", "#{JSON.stringify {'definitions':@uObjects,'configuration':@uConfigured}, null, 2}", null, (e)=>callback e
  #### help()
  # adds a help flag to argv to trigger help output from Commander
  help:->
    (@process.argv.splice 2,idx-2) if (idx = @process.argv.indexOf '-h') > -1
  #### mkGuid()
  # creates a random enough GUID
  mkGUID:->
   'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace /[xy]/g, (c)-> 
      (if (r=Math.random()*16|0)>-1 and c == 'x' then r else (r&0x3|0x8)).toString 16
  #### log(message)
  # writes message to stdout
  log: (m)->
    @process.stdout.write "#{m}\n"
  #### warn(message)
  # writes message to stdout with warning text and colors
  warn: (m)->
    @process.stdout.write "#{@strings.yellow}Warning: #{m}#{@strings.reset}\n"
  #### error(message)
  # writes error to stderr and terminates execution
  error: (m)->
    @process.stderr.write "#{@strings.red}Error: #{m}#{@strings.reset}\n"
    @process.exit 1
  applyDefinitions:(callback)->
    callback null
#### Exports for Node and Tests
exports.EzCake = ezcake
#### Run on commandline
new ezcake if process and process.argv && process.argv[1].split('/').pop() == 'ezcake'