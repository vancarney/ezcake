#!/usr/bin/env node
// Generated by CoffeeScript 1.6.2
'use strict';
var ezcake;

ezcake = (function() {
  ezcake.prototype.fs = require('fs');

  ezcake.prototype._ = require('underscore');

  ezcake.prototype.async = require('async');

  ezcake.prototype.version = '0.7';

  ezcake.prototype.process = process;

  ezcake.prototype.strings = {
    hash: '#',
    red: '\u001b[31m',
    green: '\u001b[32m',
    yellow: '\u001b[33m',
    reset: '\u001b[0m'
  };

  ezcake.prototype.paths = {};

  ezcake.prototype.name = "";

  ezcake.prototype.callbacks = {};

  ezcake.prototype.tasks = new String;

  ezcake.prototype.helpers = new String;

  ezcake.prototype.exts = [];

  ezcake.prototype.cnf = {};

  ezcake.prototype._defaults = [];

  ezcake.prototype.uConfigured = {
    tasks: [],
    commands: [],
    modules: [],
    paths: {}
  };

  ezcake.prototype.uObjects = {
    modules: {},
    commands: {},
    tasks: {},
    helpers: {},
    declarations: {}
  };

  function ezcake() {
    var _this = this;

    this._.each({
      "declarations": {},
      "helpers": {},
      "commands": {},
      "modules": {},
      "tasks": {},
      "configurations": {}
    }, function(v, k) {
      _this["" + k] = {};
      return _this["add" + (k.charAt(0).toUpperCase()) + (k.substring(1, k.length - 1))] = function(o) {
        var idx;

        if ((idx = _this._defaults.indexOf(o.name)) >= 0) {
          _this._defaults.splice(idx, 1);
        }
        return _this["" + k][o.name] = o;
      };
    });
    (this.cmd = require('commander')).version('version: #{@version}').option("-I, --ignore", "ignore global config file if defined in env.EZCAKE_HOME").option("-O, --no-override", "do not allow loaded configs to override each other").option("-l, --location <paths>", "set path(s) of config file location(s)", function(arg) {
      return arg.split(',');
    });
    this.async.series([
      (function(cb) {
        return _this.fs.realpath('.', false, function(e, path) {
          if (e != null) {
            _this.error(e);
          }
          _this.$path = path;
          return cb(null, "ok");
        });
      }), (function(cb) {
        return _this.applyDefinitions(cb);
      }), (function(cb) {
        _this._defaults = _this._.keys(_this._.extend({}, _this.modules, _this.commands, _this.tasks, _this.helpers, _this.declarations));
        return _this.preprocessArgs(cb);
      }), (function(cb) {
        if ((_this.$home = _this.process.env.EZCAKE_HOME) !== void 0 && !_this.cmd.ignore) {
          _this.loadConfig("" + _this.$home + "/ezcake.json");
        }
        if (_this.cmd.location) {
          _this._.each(_this.cmd.location, function(l) {
            return _this.loadConfig(l);
          });
        }
        return cb(null, "ok");
      }), (function(cb) {
        _this.processArgs();
        return cb(null, "ok");
      }), (function(cb) {
        if (_this.process.argv[1].split('/').pop() === 'ezcake') {
          switch (_this.command) {
            case "create":
            case "c":
              _this.onCreate();
              break;
            case "init":
            case "i":
              _this.onInit();
              break;
            default:
              _this.cmd.usage("<command> [options]\n\n  where <command> is one of:\n    create, init\n    \n  ezcake <command> -h     quick help on <command>").parse(_this.process.argv);
              _this.process.exit;
          }
        }
        _this.cmd.usage(_this.usage);
        return cb(null, "ok");
      }), (function(cb) {
        if (_this.configuration === "-h") {
          _this.configuration = null;
        }
        if (_this.configuration) {
          _this.processConfiguration();
        }
        _this.getOpts();
        return cb(null);
      }), (function(cb) {
        _this.help();
        return cb(null);
      }), (function(cb) {
        _this.cmd.parse(_this.process.argv);
        return cb(null);
      }), (function(cb) {
        return _this.getDirectives(cb);
      }), (function(cb) {
        return _this.findCustomDirectives(cb);
      }), (function(cb) {
        return _this.createPaths(cb);
      }), (function(cb) {
        return _this.writeCakeFile(cb);
      }), (function(cb) {
        if (_this.cmd.config) {
          return _this.writeConfig(cb);
        } else {
          return cb(null);
        }
      })
    ], function(err, r) {
      _this.log("" + _this.success + "\n");
      return _this.process.exit(0);
    });
  }

  ezcake.prototype.preprocessArgs = function(callback) {
    var args,
      _this = this;

    args = [];
    this._.each(this.process.argv, function(v, k) {
      if ((v.match(/^(\-h|\-\-help)+$/)) === null) {
        return args.push(v);
      }
    });
    this.cmd.parse(args);
    return callback(null);
  };

  ezcake.prototype.createDir = function(path, callback) {
    var _this = this;

    return this.fs.exists("" + path, (function(x) {
      if (!x) {
        return _this.fs.mkdir("" + path, function(e) {
          return callback(e || null);
        });
      } else {
        return callback(null);
      }
    }));
  };

  ezcake.prototype.processArgs = function() {
    var _this = this;

    if (this.process.argv.length < 3) {
      return this.process.argv.push("-h");
    } else {
      return this.process.argv.forEach(function(val, index, commandModuleArray) {
        _this.commandModuleArray = commandModuleArray;
        if (index === 0) {
          return (_this.env = val);
        }
        if (index === 1) {
          return (_this.path = val);
        }
        if (index === 2 && (typeof _this.command === 'undefined') && !(val.match(/^\-/))) {
          return (_this.command = val);
        }
        if (index === 3 && (_this.command.match(/create|init/)) && !(val.match(/^\-/))) {
          return (_this.configuration = val);
        }
        if (index === 4 && (_this.command.match(/create/)) && !(val.match(/^\-/))) {
          return (_this.name = val);
        }
      });
    }
  };

  ezcake.prototype.loadConfig = function(p) {
    var _this = this;

    return this.fs.exists(p, function(bool) {
      if (!bool) {
        return _this.warn("config file " + p + " was not found");
      }
      return _this.fs.readFile(p, function(e, d) {
        if (e != null) {
          _this.error(e);
        }
        return _this.processConfig(JSON.parse(d || {}));
      });
    });
  };

  ezcake.prototype.processConfig = function(data) {
    var _this = this;

    return this._.each(data, function(v, k) {
      var func, obj, s, _i, _len, _results;

      if (typeof _this[func = "add" + (k.charAt(0).toUpperCase()) + (k.substring(1, k.length - 1))] === 'function') {
        _results = [];
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          obj = v[_i];
          if (typeof obj['inherits'] !== 'undefined') {
            if ((s = _this[k][obj.inherits])) {
              obj = _this._.extend({}, _this[k][obj.inherits], obj);
            } else {
              _this.error("" + (k.substring(0, k.length - 1)) + " \"" + sV.inherits + "\" does not exist.");
            }
          }
          if (!(((_this.cmd != null) && _this.cmd.override === false) && _this[k][obj.name])) {
            _results.push(_this[func](obj));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    });
  };

  ezcake.prototype.onCreate = function() {
    var _this = this;

    this.usage = "create " + (this.configuration || '<type>') + " <name> [options]\n\n  Creates new " + (this.configuration || '<type>') + " configuration as directory <name> in current path";
    if (typeof this.configuration === 'undefined') {
      this.usage += "\n  Available types: " + ((this._.map(this.configurations, function(v, k, l) {
        return k;
      })).join(', '));
    }
    if (typeof this.name !== 'undefined') {
      this.$path += "/" + this.name;
    } else {
      this.process.argv.push('-h');
    }
    return this.fs.exists(this.$path, function(bool) {
      if (!bool) {
        return _this.fs.mkdir(_this.$path, function(e) {
          if (e != null) {
            _this.error(e);
          }
          return _this.success = "" + _this.configuration + " created as " + _this.name + "\n";
        });
      }
    });
  };

  ezcake.prototype.onInit = function() {
    this.usage = "init " + (this.configuration || '<type>') + " [options]\n\n  Creates or Updates " + (this.configuration || '<type>') + " Cakefile in current Project Directory";
    if (typeof this.configuration === 'undefined') {
      this.usage += "\n  Available types: " + ((this._.map(this.configurations, function(v, k, l) {
        return k;
      })).join(', '));
    }
    return this.success = "Cakefile updated!\n";
  };

  ezcake.prototype.processConfiguration = function() {
    if (typeof (this.cnf = this.configurations[this.configuration]) !== 'undefined') {
      return this.cmd.option("-F, --no-config", "Do not create ezcake config file");
    } else {
      return this.process.argv.push("-h");
    }
  };

  ezcake.prototype.getOpts = function() {
    var _this = this;

    return this._.each((this.commandModuleArr = [].concat(this.cnf.modules, this.cnf.commands)), function(v, k) {
      var t;

      if ((t = _this.modules[v] || _this.commands[v]) !== void 0) {
        _this.cmd.option(t.command[0], t.command[1]);
        if ((_this._.indexOf(t.command[1])) > -1 || _this.process.argv[_this.process.argv.length - 1].match(new RegExp("[" + (t.command[0].charAt(1)) + "]+"))) {
          if (typeof t.setFlag !== 'undefined' && (t.setFlag != null)) {
            return _this.process.argv.push(t.setFlag);
          }
        }
      } else {
        return _this.error("" + v + " was not defined");
      }
    });
  };

  ezcake.prototype.hasRequired = function() {
    var has,
      _this = this;

    has = this._.every(this._.flatten(this._.pluck(this.uConfigured, "required")), function(val) {
      return (_this._.find(_this._.pluck(_this._.extend({}, _this.declarations, _this.helpers, _this.uConfigured.modules), "name"), function(n) {
        return n === val;
      })) || false;
    });
    if (!has) {
      throw new Error("'" + val + "' was required but not found");
    }
    return true;
  };

  ezcake.prototype.getDirectives = function(callback) {
    var _this = this;

    this._.each(this.commandModuleArr, function(v, k) {
      var setpath, t;

      if (typeof _this.cmd[v] !== 'undefined' && _this.cmd[v]) {
        if (typeof _this.modules[v] !== 'undefined' && ((t = _this.modules[v]) != null)) {
          _this.uConfigured.modules.push(v);
        } else if (typeof _this.commands[v] !== 'undefined' && ((t = _this.commands[v]) != null)) {
          _this.uConfigured.commands.push(v);
        } else {
          callback("" + v + " was not defined");
        }
        if (typeof t.callback !== 'undefined') {
          _this.callbacks["on" + (t.callback.charAt(0).toUpperCase()) + (t.callback.substring(1, t.callback.length))] = "" + _this.strings.hash + " Callback From '" + v + "'\n" + t.callback + "=()->\n";
        }
        switch (Object.prototype.toString.call(t.paths)) {
          case '[object Object]':
            setpath = t.paths;
            break;
          case '[object Array]':
            setpath = JSON.parse("{\"" + v + "\":" + (JSON.stringify(t.paths)) + "}");
            break;
          case 'undefined':
            break;
          default:
            setpath = void 0;
        }
        if (typeof t.paths !== 'undefined') {
          return _this.paths = _this._.extend(_this.paths, setpath);
        }
      }
    });
    this.paths = this._.extend(this.paths, this.cnf.paths);
    this.modules = this._.pick(this.modules, this.uConfigured.modules);
    this.commands = this._.pick(this.commands, this.uConfigured.commands);
    return callback(null);
  };

  ezcake.prototype.findCustomDirectives = function(callback) {
    var kind, name, obj, _i, _j, _len, _len1, _ref, _ref1;

    _ref = this._.difference(this._.extend({}, this._.keys(this.modules, this._.keys(this.commands, this._.keys(this.tasks, this._.keys(this.helpers, this._.keys(this.declarations)))))), this._defaults);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _ref1 = ["commands", "modules", "tasks", "helpers", "declarations"];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        kind = _ref1[_j];
        if ((obj = this[kind][name]) != null) {
          this.uObjects[kind][name] = obj;
        }
      }
    }
    return callback(null);
  };

  ezcake.prototype.getExts = function() {
    return this._.compact(this._.pluck(this.modules, 'ext'));
  };

  ezcake.prototype.getPaths = function() {
    var f,
      _this = this;

    f = [];
    this._.each(this.paths, function(v, k) {
      if (typeof _this.cmd[v] === 'undefined' || !_this.cmd[v]) {
        _this.uConfigured.paths[k] = v;
        return f = f.concat(_this._.flatten(_this._.toArray(v)));
      }
    });
    return f;
  };

  ezcake.prototype.createPaths = function(cb) {
    var _this = this;

    return this.async.each(["", "src"].concat(this.getPaths()), (function(p, cb2) {
      var arr, path;

      path = "" + _this.$path;
      arr = p.split('/');
      arr.splice(-1, 0, '');
      return _this.async.each(arr, (function(item, cb3) {
        return _this.createDir((path = "" + (path.replace(/\/$/, '')) + "/" + item), cb3);
      }), function(e) {
        return cb2(null);
      });
    }), function(e) {
      return cb(null);
    });
  };

  ezcake.prototype.getDeclarations = function() {
    var _this = this;

    return this._.map(this.declarations, function(v, k) {
      if (v.body) {
        return "" + _this.strings.hash + " " + (v.description || v.name + 'header') + "\n" + v.body;
      }
    }).join('\n');
  };

  ezcake.prototype.getCallbacks = function() {
    var _this = this;

    this._.each(this.callbacks, function(cb, cn) {
      return _this._.each(_this._.pluck(_this._.extend({}, _this.modules, _this.commands), cn), function(cV, cK) {
        if (typeof cV !== 'undefined') {
          return _this.callbacks[cn] = new String(_this.callbacks[cn] + cV);
        }
      });
    });
    return (this._.values(this.callbacks)).join('\n');
  };

  ezcake.prototype.getHelpers = function() {
    var helpers,
      _this = this;

    helpers = "";
    this._.each(this.helpers, function(v, k, l) {
      return helpers += "" + _this.strings.hash + " " + (v.description || k(+"helper method")) + "\n" + k + " = " + v.body;
    });
    return helpers;
  };

  ezcake.prototype.getTasks = function() {
    var tasks,
      _this = this;

    tasks = "";
    if (typeof this.cnf.tasks !== 'undefined') {
      this._.each(this.cnf.tasks, function(v, k, l) {
        var body, handlerName;

        if (_this.tasks[v] != null) {
          _this.uConfigured.tasks.push(v);
          handlerName = "on" + (v.charAt(0).toUpperCase()) + (v.slice(1));
          body = "" + (_this.tasks[v].body || new String);
          _this._.each(_this.uConfigured.commands, function(v, k) {
            var invocation;

            if (_this.commands[v].invocations != null) {
              if ((invocation = _this._.where(_this.commands[v].invocations, {
                call: handlerName
              })).length) {
                return body += "" + _this.strings.hash + " From Command '" + v + "'\n  " + ('# ' + _this.commands[v].description) + "\n  " + invocation[0].body + "\n  ";
              }
            }
          });
          _this._.each(_this.uConfigured.modules, function(v, k) {
            var invocation;

            if (_this.modules[v].invocations != null) {
              if ((invocation = _this._.where(_this.modules[v].invocations, {
                call: handlerName
              })).length) {
                return body += "" + _this.strings.hash + " From Module '" + v + "'\n  " + ('# ' + _this.modules[v].description) + "\n  " + invocation[0].body + "\n  ";
              }
            }
          });
          return tasks += "" + _this.strings.hash + " " + _this.strings.hash + _this.strings.hash + " *" + v + "*\n" + _this.strings.hash + " " + _this.tasks[v].description + "\ntask '" + v + "', '" + _this.tasks[v].description + "', (" + (_this.tasks[v].args || new String) + ")-> " + (v.replace(/:/g, '_')) + " -> log ':)', green\n" + (v.replace(/:/g, '_')) + " = (" + (_this.tasks[v].args || new String) + ")->\n  " + body + "\n\n";
        }
      });
    }
    return tasks;
  };

  ezcake.prototype.toJSON = function() {
    return {
      declarations: this.declarations,
      helpers: this.helpers,
      commands: this.commands,
      modules: this.modules,
      tasks: this.tasks,
      configurations: this.configurations
    };
  };

  ezcake.prototype.toString = function() {
    return JSON.stringify(this.toJSON(), null, 2);
  };

  ezcake.prototype.writeCakeFile = function(callback) {
    var s,
      _this = this;

    s = "" + this.strings.hash + " Another Cakefile made with love by ezcake v" + this.version + "\n" + (this.getDeclarations()) + "\n# paths object for module invocation reference\npaths=" + (JSON.stringify(this.cnf.paths, null, 2)) + "\n# file extensions for watching\nexts='" + (this.getExts().join('|')) + "'\n" + this.strings.hash + " Begin Callback Handlers\n" + (this.getCallbacks()) + "\n" + this.strings.hash + " Begin Tasks\n" + (this.getTasks()) + "\n" + this.strings.hash + " Begin Helpers\n" + (this.getHelpers());
    return this.fs.writeFile("" + this.$path + "/Cakefile", s, null, function(e) {
      return callback(e);
    });
  };

  ezcake.prototype.writeConfig = function(callback) {
    var _this = this;

    return this.fs.writeFile("" + this.$path + "/ezcake.json", "" + (JSON.stringify({
      'definitions': this.uObjects,
      'configuration': this.uConfigured
    }, null, 2)), null, function(e) {
      return callback(e);
    });
  };

  ezcake.prototype.help = function() {
    var idx;

    if ((idx = this.process.argv.indexOf('-h')) > -1) {
      return this.process.argv.splice(2, idx - 2);
    }
  };

  ezcake.prototype.mkGUID = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r;

      return ((r = Math.random() * 16 | 0) > -1 && c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  ezcake.prototype.log = function(m) {
    return this.process.stdout.write("" + m + "\n");
  };

  ezcake.prototype.warn = function(m) {
    return this.process.stdout.write("" + this.strings.yellow + "Warning: " + m + this.strings.reset + "\n");
  };

  ezcake.prototype.error = function(m) {
    this.process.stderr.write("" + this.strings.red + "Error: " + m + this.strings.reset + "\n");
    return this.process.exit(1);
  };

  ezcake.prototype.applyDefinitions = function(callback) {
    this.addDeclaration({
      name: "fs",
      description: "require Node::FS",
      body: "fs = require 'fs'"
    });
    this.addDeclaration({
      name: "utils",
      description: "require Node::Util",
      body: "{debug, error, log, print} = require 'util'"
    });
    this.addDeclaration({
      name: "child_process",
      description: "import Spawn and Exec from child_process",
      body: "{spawn, exec, execFile}=require 'child_process'"
    });
    this.addDeclaration({
      name: "which",
      description: "try to import the Which module",
      body: "try\n  which = (require 'which').sync\ncatch err\n  if process.platform.match(/^win/)?\n    error 'The which module is required for windows. try \"npm install which\"'\n  which = null"
    });
    this.addDeclaration({
      name: "colors",
      description: "set Terminal Colors",
      block: "" + this.strings.hash + " ANSI Terminal Colors\nbold = '\x1b[0;1m'\ngreen = '\x1b[0;32m'\nred = '\x1b[0;31m'\nreset = '\x1b[0m'"
    });
    this.addHelper({
      name: "launch",
      description: " ",
      requires: {
        declarations: ["child_process"]
      },
      body: "(cmd, options=[], callback) ->\n  cmd = which(cmd) if which\n  app = spawn cmd, options\n  app.stdout.pipe(process.stdout)\n  app.stderr.pipe(process.stderr)\n  app.on 'exit', (status) -> callback?() if status is 0"
    });
    this.addHelper({
      name: "log",
      requires: {
        declarations: ["colors"]
      },
      description: " ",
      body: "(message, color, explanation) -> \n  console.log color+message+reset+(explanation or '')"
    });
    this.addHelper({
      name: "moduleExists",
      description: " ",
      body: "(name) ->\n  try \n    require name \n  catch err \n    error name+ 'required: npm install '+name, red\n    false"
    });
    this.addHelper({
      name: "bin",
      description: " ",
      requires: {
        declarations: ["fs"]
      },
      body: "(file) ->\n  if file.match /\.coffee$/\n    fs.unlink file.replace(/\.coffee$/, '.js')\n    true\n  else false"
    });
    this.addHelper({
      name: "walk",
      description: " ",
      requires: {
        declarations: ["fs"]
      },
      body: "(dir, done) ->\n  " + this.strings.hash + " Directory Traversal\n  results = []\n  fs.readdir dir, (err, list) =>\n    return done(err, []) if err\n    pending = list.length\n    return done(null, results) unless pending\n    for name in list\n      fs.stat dir+'/'+name, (e,stat)=>\n        stat = null if e?\n        if stat?.isDirectory()\n          walk file, (err, res) =>\n            results.push name for name in res\n            done(null, results) unless --pending\n        else\n          results.push file\n          done(null, results) unless --pending\n\n\n"
    });
    this.addTask({
      name: "build",
      description: "Compiles Sources"
    });
    this.addTask({
      name: "build:release",
      description: "Copy contents of debug to web release folder and minify",
      paths: ["debug", "www"],
      body: "exec \"cp -r " + this.strings.hash + "{paths.release[0]} " + this.strings.hash + "{paths.release[1]}\" if paths? and paths.release"
    });
    this.addTask({
      name: "watch",
      description: "watch project src folders and build on change"
    });
    this.addTask({
      name: "docs",
      description: "Generate Documentation",
      paths: ["docs"]
    });
    this.addTask({
      name: "minify",
      description: "Minify Generated JS and HTML"
    });
    this.addTask({
      name: "readme",
      description: "Generate ReadMe HTML from Markdown"
    });
    this.addTask({
      name: "test",
      description: "Runs your test suite.",
      args: ["options=[]", "callback"],
      paths: ["tests"]
    });
    this.addTask({
      name: "clean",
      description: "Cleans up generated js paths",
      body: "  try\n    for file in paths.coffee\n      unless unlinkIfCoffeeFile file\n        walk file, (err, results) ->\n          for f in results\n            unlinkIfCoffeeFile f\n\n    callback?()\n  catch err\n    console.error red+err"
    });
    this.addTask({
      name: "up2date",
      description: "installs/updates referenced NPMs and Gems",
      body: ""
    });
    this.addModule({
      name: "coffee",
      description: "Enable coffee-script compiling",
      ext: "coffee",
      installer: "npm",
      installer_alias: "coffee-script",
      installer_options: "-g",
      paths: [".", "src/coffee"],
      callback: "coffeeCallback",
      command: ['-0, --no-coffee', 'don\'t use coffee-script (js only)'],
      invocations: [
        {
          call: "onBuild",
          body: "launch 'coffee', (['-c', '-b', '-l', '-o' ].concat paths.coffee), coffeeCallback"
        }
      ]
    });
    this.addModule({
      name: "scss",
      description: "use SCSS/SASS instead of less (requires ruby gems)",
      ext: "scss",
      installer: "gem",
      installer_alias: "sass",
      callback: "scssCallback",
      paths: ["src/scss", "www/css"],
      command: ['-s, --scss', 'use scss (sass) instead of less (requires ruby gems)'],
      setFlag: "-L",
      invocations: [
        {
          call: "onBuild",
          body: "launch 'sass', paths.sass, scssCallback"
        }
      ]
    });
    this.addModule({
      name: "less",
      description: " ",
      ext: "less",
      installer: "npm",
      installer_options: "-g",
      callback: "lessCallback",
      paths: ["src/less", "www/css"],
      command: ['-L, --no-less', 'do not use less'],
      invocations: [
        {
          call: "onBuild",
          body: "launch 'lessc', paths.less, lessCallback"
        }
      ]
    });
    this.addModule({
      name: "jade",
      description: " ",
      ext: "jade",
      installer: "npm",
      installer_options: "-g",
      paths: ["src/jade", "www", "src/jade/templates", "src/jade/includes"],
      command: ['-J, --no-jade', 'do not use Jade templates'],
      invocations: [
        {
          call: "onBuild",
          body: "exec \"jade " + this.strings.hash + "{paths.jade[2]} -v --pretty --out " + this.strings.hash + "{paths.jade[1]}\" "
        }
      ]
    });
    this.addModule({
      name: "jst",
      description: " ",
      ext: "js",
      installer: "npm",
      installer_alias: "universal-jst",
      installer_options: "-g",
      paths: ["src/jst", "www/js"],
      allowed: ['dust', 'mustache', 'handlebars', 'hogan'],
      command: ['-t, --jst <engine>', 'use javascript template engine [dust,mustache,handlebars,hogan]', String, 'dust'],
      invocations: [
        {
          call: "onBuild",
          body: "exec \"jst -t dust " + this.strings.hash + "{paths.jst[0]} > " + this.strings.hash + "{paths.jst[1]}\" "
        }
      ]
    });
    this.addModule({
      name: "jquery",
      description: " ",
      installer: "npm",
      installer_options: "-g",
      command: ['-q, --jquery', 'use jQuery for node']
    });
    this.addModule({
      name: "mocha",
      description: " ",
      installer: "npm",
      installer_options: "-g",
      paths: ['test'],
      command: ['-M, --no-mocha', 'disable mocha support'],
      invocations: [
        {
          call: "onTest",
          body: "if moduleExists('mocha')\n    if typeof options is 'function'\n      callback = options\n      options = []\n    " + this.strings.hash + " add coffee directive\n    options.push '--compilers'\n    options.push 'coffee:coffee-script'\n    \n    launch 'mocha', options, callback"
        }
      ]
    });
    this.addModule({
      name: "chai",
      description: " ",
      requires: {
        modules: ["mocha"]
      },
      installer: "npm",
      installer_options: "-g",
      paths: ['test'],
      command: ['-C, --no-chai', 'disable chai support']
    });
    this.addModule({
      name: "supervisor",
      description: "Use Supervisor for file watching ",
      installer: "npm",
      installer_options: "-g",
      command: ['-S, --no-superpvisor', 'disable supervisor support'],
      paths: ['src'],
      invocations: [
        {
          call: "onWatch",
          body: "exec \"supervisor -e '" + this.strings.hash + "{exts}' -n exit -q -w '" + this.strings.hash + "{paths.supervisor[0]}' -x 'cake' build\" "
        }
      ]
    });
    this.addModule({
      name: "docco",
      description: " ",
      installer: "npm",
      installer_options: "-g",
      requires: {
        declarations: ["child_process"],
        helpers: ["walk"],
        modules: ["coffee"]
      },
      command: ['-D, --no-docco', 'disable docco support'],
      callback: "doccoCallback",
      invocations: [
        {
          call: "onDocs",
          body: "if moduleExists 'docco' && paths? && paths.coffee\n    walk paths.coffee[0], (err, paths) ->\n      try\n        launch 'docco', paths, doccoCallback()\n      catch e\n        error e"
        }
      ]
    });
    this.addModule({
      name: "markdown",
      description: " ",
      installer: "gem",
      requires: {
        declarations: ["child_process"]
      },
      command: ['-k, --markdown', 'enable markdown parsing (requires ruby gems, Python and PEAK)'],
      invocations: [
        {
          call: "onReadme",
          body: "-> launch 'markdown'"
        }
      ]
    });
    this.addModule({
      name: "compass",
      description: " ",
      installer: "gem",
      ext: "scss",
      requires: {
        declarations: ["child_process"]
      },
      callback: "compassCallback",
      command: ['-c, --compass', 'use Compass for SCSS (requires ruby gems)'],
      invocations: [
        {
          call: "onBuild",
          body: "launch 'compass', ['compile', '--sass-dir=" + this.strings.hash + "{paths.scss[1]}', '--css-dir=" + this.strings.hash + "{paths.scss[0]}'], callback"
        }
      ]
    });
    this.addModule({
      name: "uglifyjs",
      description: " ",
      installer: "npm",
      installer_options: "-g",
      requires: {
        declarations: ["child_process"],
        helpers: ["walk"]
      },
      command: ["-U, --no-uglify", "do not use uglifyjs"],
      callback: "minifyCallback",
      invocations: [
        {
          call: "onMinify",
          body: "" + this.strings.hash + " minify js and html paths\n  if paths? and paths.uglify?\n    walk \"" + this.strings.hash + "{paths.uglify[0]}\", (err, results) =>\n      for file in results\n        continue if file.match /\.min\.js+$/\n        launch 'uglifyjs', if file.match /\.js+$/ then ['--output', \"dir/" + this.strings.hash + "{file.replace /\.js+$/,'.min.js'}\", file] else ['--output', \"dir/" + this.strings.hash + "{file}\", file]"
        }
      ]
    });
    this.addCommand({
      name: "assets",
      description: " Copies Assets from src directory in build directory ",
      command: ['-A, --no-assets', 'disable static asset copying from src directory'],
      requires: {
        declarations: ["child_process"]
      },
      invocations: [
        {
          call: "onBuild",
          body: "exec \"cp -r " + this.strings.hash + "{paths.assets[0]} " + this.strings.hash + "{paths.assets[1]}\" if paths? and paths.assets?"
        }
      ]
    });
    this.addCommand({
      name: "bin",
      description: " ",
      paths: ['bin', 'src/coffee/bin'],
      requires: {
        declarations: ["child_process", "fs"]
      },
      command: ['-b, --bin', 'create \'bin\' output and source directories (useful for nodejs commandline apps)'],
      invocations: [
        {
          call: "onCoffeeCallback",
          body: "" + this.strings.hash + " try to move bin folder and cat shabang onto all files in ./bin, deleting original .js files when dones\n  try\n    exec \"mv " + this.strings.hash + "{paths.coffee[0]}/" + this.strings.hash + "{paths.bin[0]}/* " + this.strings.hash + "{paths.bin[0]}\" if paths.coffee?\n    fs.readdir (\"" + this.strings.hash + "{paths.coffee[0]}/" + this.strings.hash + "{paths.bin[0]}\")), (e,files)=>\n      console.error e if e?\n      for file in files\n        if file.match /\.js+$/\n          out = \"" + this.strings.hash + "{paths.bin[0]}/" + this.strings.hash + "{file}\".split('.').shift()\n          exec \"echo '" + this.strings.hash + "!/usr/bin/env node' | cat - " + this.strings.hash + "{paths.bin[0]}/" + this.strings.hash + "{file} > " + this.strings.hash + "{out}\", =>\n            fs.unlink \"" + this.strings.hash + "{paths.bin[0]}/" + this.strings.hash + "{file}\""
        }
      ]
    });
    this.addCommand({
      name: "lib",
      description: " ",
      paths: {
        coffee: ["lib", "src/coffee"]
      },
      command: ['-L, --no-lib', 'do not create \'lib\' output and source directories']
    });
    this.addCommand({
      name: "force",
      description: " ",
      command: ['-f, --force', 'force overwrite of default configurations']
    });
    this.addCommand({
      name: "noJST",
      description: " ",
      command: ['-T, --no-jst', 'disable javascript template parsing']
    });
    this.addConfiguration({
      name: "web",
      description: " ",
      commands: ['assets', 'noJST'],
      modules: ['coffee', 'jade', 'less', 'scss', 'compass', 'jst', 'docco', 'mocha', 'uglifyjs', 'markdown'],
      tasks: ["build", "build:release", "watch", "minify", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        release: ['debug', 'www'],
        assets: ["src/assets", "debug"],
        coffee: ["debug/js", "src/coffee"],
        uglify: ['www'],
        less: ['src/less', 'debug/css'],
        jade: ["src/jade", "debug", "src/jade/templates", "src/jade/include"],
        jst: ["src/jst", "debug/js"]
      },
      invocations: [
        {
          call: "onBuild:release",
          body: "minify()"
        }
      ]
    });
    this.addConfiguration({
      name: "plugin",
      description: " ",
      commands: ['assets', 'lib'],
      modules: ['coffee', 'jade', 'less', 'scss', 'compass', 'docco', 'mocha', 'uglifyjs', 'markdown'],
      tasks: ["build", "watch", "minify", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        demo: ["demo"],
        uglify: ['lib'],
        assets: ["src/assets", "lib"],
        coffee: ["lib", "src/coffee"],
        jade: ["src/jade", "demo", "src/jade/templates", "src/jade/include"]
      }
    });
    this.addConfiguration({
      name: "node-npm",
      description: " ",
      commands: ['lib', 'bin'],
      modules: ['coffee', 'docco', 'mocha', 'markdown'],
      tasks: ["build", "watch", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        coffee: [".", "src/coffee"],
        bin: ["src/coffee/newbin", "newbin"]
      }
    });
    this.addConfiguration(this._.extend({}, this.configurations['node-npm'], {
      name: "npm"
    }));
    this.addConfiguration({
      name: "node-app",
      description: " ",
      commands: ['lib'],
      modules: ['coffee', 'docco', 'mocha', 'markdown'],
      tasks: ["build", "watch", "docs", "test", 'up2date'],
      files: "README.md",
      paths: {
        coffee: ["src/coffee", "."]
      }
    });
    this.addConfiguration(this._.extend({}, this.configurations['node-app'], {
      name: "app"
    }));
    return callback(null);
  };

  return ezcake;

})();

(typeof exports !== "undefined" && exports !== null ? exports : window).EzCake = ezcake;

if (process && process.argv && process.argv[1].split('/').pop() === 'ezcake') {
  new ezcake;
}
