#!/usr/bin/env node
// Generated by CoffeeScript 1.7.1
(function() {
  var CakefileRenderer, ConfigLoader, FileHelpers, NPMPackage, Processor, async, cmd, ezcake, fs, http, path, require_tree, _;

  ezcake = (function() {
    ezcake.prototype.version = '0.0.1';

    ezcake.prototype.module_path = process.mainModule.filename.split('/bin').shift();

    ezcake.prototype.config_path = "data/json/default";

    function ezcake() {
      this.configs = new ConfigLoader;
      this.user_home_exists = false;
      this.user_config_exists = false;
      this.uPath = process.cwd();
      async.series([
        ((function(_this) {
          return function(cb) {
            return _this.createOpts(cb);
          };
        })(this)), ((function(_this) {
          return function(cb) {
            return fs.realpath('.', false, function(e, path) {
              if (e != null) {
                ezcake.error(e);
              }
              _this.$path = path;
              return cb(null, "ok");
            });
          };
        })(this)), ((function(_this) {
          return function(cb) {
            if ((_this.home = process.env.EZCAKE_HOME) !== void 0) {
              return fs.exists("" + _this.home, function(bool) {
                _this.user_home_exists = bool;
                return fs.exists("" + _this.home + "/ezcake.json", function(bool) {
                  _this.user_config_exists = bool;
                  return cb(null);
                });
              });
            } else {
              return cb(null);
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            return _this.preProcessArgs(cb);
          };
        })(this)), ((function(_this) {
          return function(cb) {
            switch (process.argv[2]) {
              case 'create':
              case 'update':
              case 'list':
              case 'publish':
                return _this.create_or_update(cb);
              default:
                return _this.processArgs(cb);
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            if (process.argv[1].split('/').pop() === 'ezcake') {
              switch (ezcake.COMMAND) {
                case "create":
                  _this.onCreate();
                  break;
                case "update":
                  _this.onUpdate();
                  break;
                case "install":
                  _this.onCreate();
                  break;
                case "uninstall":
                  _this.onUninstall();
                  break;
                case "list":
                  _this.onList();
                  break;
                case "search":
                  _this.onSearch();
                  break;
                case "publish":
                  _this.onPublish();
                  break;
                case "unpublish":
                  _this.onUnpublish();
                  break;
                default:
                  if (typeof ezcake.COMMAND === 'undefined') {
                    cmd.usage("<command> [options]\n\n  where <command> is one of:\n    create, update, install, uninstall, list, search, publish, unpublish\n    \n  hint: 'ezcake <command> -h' will give quick help on <command>").parse(process.argv);
                    process.exit(0);
                  } else {
                    ezcake.error("Command must be either 'create', 'update' or 'publish' try \'ezcake create " + ezcake.COMMAND + "'");
                  }
              }
            }
            cmd.usage(_this.usage);
            return cb(null, "ok");
          };
        })(this)), ((function(_this) {
          return function(cb) {
            if (ezcake.CONFIG === "-h") {
              ezcake.CONFIG = null;
            }
            switch (ezcake.COMMAND) {
              case 'create':
              case 'update':
              case 'list':
                return _this.processConfiguration(cb);
              case 'publish':
                return _this.loadConfiguration(ezcake.PATH);
              case 'unpublish':
                console.log("ezcake.PATH: " + ezcake.PATH);
                return _this.loadConfiguration(ezcake.PATH);
              case 'search':
                return console.log('search');
              default:
                process.argv.push('-h');
                _this.help();
                cmd.parse(process.argv);
                return process.exit(0);
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            return _this.getOpts(cb);
          };
        })(this)), ((function(_this) {
          return function(cb) {
            if (_this.help()) {
              process.argv.push('-h');
            }
            return cb(null);
          };
        })(this)), ((function(_this) {
          return function(cb) {
            cmd.parse(process.argv);
            return cb(null);
          };
        })(this)), ((function(_this) {
          return function(cb) {
            switch (ezcake.COMMAND) {
              case 'create':
              case 'update':
                console.log("@create_or_update_complete");
                return _this.create_or_update_complete(cb);
              default:
                return cb('command was not set');
            }
          };
        })(this))
      ], (function(_this) {
        return function(err, r) {
          ezcake.log("" + ezcake.strings.green + "ezCake completed" + ezcake.strings.reset + "\n");
          return process.exit(0);
        };
      })(this));
    }

    ezcake.prototype.create_or_update = function(callback) {
      return async.series([
        ((function(_this) {
          return function(cb) {
            var e, p;
            if (_this.user_config_exists && cmd.ignore) {
              try {
                process.chdir(p = _.initial(_this.home.split(path.sep)).join(path.sep));
              } catch (_error) {
                e = _error;
                ezcake.error("Failed to change working directory to '" + p + "'. " + e);
              }
              return _this.configs.loadConfig(_.last(_this.home.split(path.sep)), function() {
                return cb();
              });
            } else {
              try {
                process.chdir(p = _.initial(("" + _this.module_path + "/" + _this.config_path).split(path.sep)).join(path.sep));
              } catch (_error) {
                e = _error;
                ezcake.error("Failed to change working directory to '" + p + "'. " + e);
              }
              return _this.configs.loadConfig(_.last(_this.config_path.split(path.sep)), function() {
                if (_this.user_home_exists) {
                  try {
                    process.chdir(p = _.initial(_this.home.split(path.sep)).join(path.sep));
                  } catch (_error) {
                    e = _error;
                    ezcake.error("Failed to change working directory to '" + p + "'. " + e);
                  }
                  return _this.configs.loadConfig(_.last(_this.home.split(path.sep)), function() {
                    process.chdir(_this.uPath);
                    return cb();
                  });
                } else {
                  process.chdir(_this.uPath);
                  return cb();
                }
              });
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            if (cmd.location) {
              return _.each(cmd.location, function(location, idx) {
                process.chdir(_.initial(location.split(path.sep)).join(path.sep));
                return _this.configs.loadConfig(_.last(location.split(path.sep)), function() {
                  process.chdir(_this.uPath);
                  if (idx === cmd.location.length - 1) {
                    return cb(null, "ok");
                  }
                });
              });
            } else {
              return cb(null, "ok");
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            _this.configs.mergeConfigs();
            return cb(null);
          };
        })(this)), ((function(_this) {
          return function(cb) {
            _this.configs.extendConfigurations();
            return _this.processArgs(cb);
          };
        })(this))
      ], (function(_this) {
        return function(e) {
          return typeof callback === "function" ? callback(e) : void 0;
        };
      })(this));
    };

    ezcake.prototype.create_or_update_complete = function(callback) {
      return async.series([
        ((function(_this) {
          return function(cb) {
            var paths;
            _this.processor = new Processor(_this.configs.selectedConfig());
            _this.fileHelpers = new FileHelpers(_this.$path);
            if (_.keys(paths = _this.processor.getPaths()).length) {
              return _this.fileHelpers.createPaths(_.map(paths, function(v, k) {
                return v;
              }), cb);
            } else {
              return cb();
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            var files;
            if (_.keys(files = _this.processor.getFiles()).length) {
              return _this.fileHelpers.createFiles(_.map(files, function(v, k) {
                return v;
              }), cb);
            } else {
              return cb();
            }
          };
        })(this)), ((function(_this) {
          return function(cb) {
            var config, deps;
            config = _this.processor.generateConfiguration();
            console.log(JSON.stringify(_this.processor.getDependencies(), null, 2));
            _this.npmPackage = new NPMPackage(_this.$path);
            _this.npmPackage.addDependencies(_.where((deps = _this.processor.getDependencies()), {
              type: 'npm',
              development: false
            }));
            _this.npmPackage.addDependencies(_.where(deps, {
              type: 'npm',
              development: true
            }), true);
            return (new CakefileRenderer(_this.$path, "" + (path.join(_this.module_path, _this.configs.__config.cake_template)))).render(config, cb);
          };
        })(this))
      ], (function(_this) {
        return function(e) {
          return typeof callback === "function" ? callback(e) : void 0;
        };
      })(this));
    };

    return ezcake;

  })();

  ezcake.ENV = void 0;

  ezcake.PATH = void 0;

  ezcake.NAME = void 0;

  ezcake.PATH = void 0;

  ezcake.CONFIG = void 0;

  ezcake.COMMAND = void 0;

  ezcake.prototype.onCreate = function() {
    this.usage = "create " + (ezcake.CONFIG || '<type>') + " <name> [options]\n\n  Creates new " + (ezcake.CONFIG || '<type>') + " configuration as directory <name> in current path";
    if (typeof ezcake.CONFIG === 'undefined') {
      this.usage += "\n  Available types: " + (this.configs.listConfigurations().join(', '));
    }
    if (typeof ezcake.NAME !== 'undefined') {
      return this.$path += "/" + ezcake.NAME;
    } else {
      return process.argv.push('-h');
    }
  };

  ezcake.prototype.onUpdate = function() {
    this.usage = "update " + (ezcake.CONFIG || '<type>') + " [options]\n\n  Creates or Updates " + (ezcake.CONFIG || '<type>') + " Cakefile in current Project Directory";
    if (typeof ezcake.CONFIG === 'undefined') {
      this.usage += "\n  Available types: " + (configs.listConfigurations().join(', '));
    }
    return this.success = "Cakefile updated!\n";
  };

  ezcake.prototype.onList = function() {
    this.usage = "list [type] [options]\n\n  Lists available ezcake elements in ezcake load paths";
    return this.success = "\n";
  };

  ezcake.prototype.onSearch = function() {
    this.usage = "search [name] [options]\n\n  Search for ezcake elements on ezcake.co";
    return this.success = "\n";
  };

  ezcake.prototype.onPublish = function() {
    this.usage = "publish " + (ezcake.PATH || '<path>') + " [options]\n\n  Publish to ezcake.co";
    return this.success = "" + ezcake.PATH + " published\n";
  };

  ezcake.prototype.onUnpublish = function() {
    this.usage = "unpublish " + (ezcake.PATH || '<path>') + " [options]\n\n  unpublishes config from ezcake.co";
    return this.success = "" + ezcake.PATH + " unpublished\n";
  };

  ezcake.prototype.onInstall = function() {
    this.usage = "install " + (ezcake.CONFIG || '<config>') + " [options]\n\n  install configuration from ezcake.co";
    return this.success = "" + ezcake.CONFIG + " installed\n";
  };

  ezcake.prototype.onUninstall = function() {
    this.usage = "uninstall " + (ezcake.CONFIG || '<config>') + " [options]\n\n  uninstall configuration from ezcake.co";
    return this.success = "" + ezcake.CONFIG + " uninstall\n";
  };

  ezcake.prototype.preProcessArgs = function(callback) {
    var args;
    args = [];
    _.each(process.argv, (function(_this) {
      return function(v, k) {
        if ((v.match(/^(\-h|\-\-help)+$/)) === null) {
          return args.push(v);
        }
      };
    })(this));
    cmd.parse(args);
    return callback(null);
  };

  ezcake.prototype.processArgs = function(cB) {
    if (process.argv.length < 3) {
      process.argv.push('-h');
    } else {
      process.argv.forEach((function(_this) {
        return function(val, index) {
          if (index === 0) {
            return (ezcake.ENV = val);
          }
          if (index === 1) {
            return (ezcake.PATH = val);
          }
          if (index === 2 && (typeof ezcake.COMMAND === 'undefined') && !(val.match(/^\-/))) {
            return (ezcake.COMMAND = val);
          }
          if (index === 3 && (ezcake.COMMAND.match(/create|update|list|install|uninstall/)) && !(val.match(/^\-/))) {
            return (ezcake.CONFIG = val);
          }
          if (index === 3 && (ezcake.COMMAND.match(/publish|unpublish/)) && !(val.match(/^\-/))) {
            return (ezcake.PATH = val);
          }
          if (index === 4 && (ezcake.COMMAND.match(/create/)) && !(val.match(/^\-/))) {
            return (ezcake.NAME = val);
          }
        };
      })(this));
    }
    return cB();
  };

  ezcake.prototype.processConfiguration = function(cB) {
    var configs;
    if (!(configs = this.configs.getConfigurations())) {
      return ezcake.error('No Configurations loaded');
    }
    if (typeof _.findWhere(configs, {
      name: ezcake.CONFIG
    }) !== 'undefined') {
      cmd.option("-F, --no-config", "Do not create ezcake config file");
      return cB();
    } else {
      return ezcake.error("Configuration '" + ezcake.CONFIG + "' was not found");
    }
  };

  ezcake.prototype.loadConfiguration = function(p, cB) {
    var keys, loader;
    keys = ['bundles', 'commands', 'helpers', 'cake_template', 'modules', 'options', 'tasks', 'paths', 'templates'];
    return (loader = new ConfigLoader()).loadConfig(path.normalize(p), (function(_this) {
      return function() {
        var config, data, elements, opts, req;
        config = _.clone(loader.__loader[loader.__loader.require_tree.loadedConfigs[0]]);
        elements = _this.configs.__loader[_this.configs.__loader.require_tree.loadedConfigs[0]];
        _.each(keys, function(v) {
          return config[v] = _.find(elements, function(idx, o) {
            return v.lastIndexOf(o.name > -1);
          });
        });
        data = "" + (JSON.stringify(config)) + "\n";
        opts = {
          hostname: '0.0.0.0',
          port: 3000,
          path: '/api',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': data.length
          }
        };
        req = http.request(opts, function(res) {
          res.setEncoding('utf8');
          console.log("STATUS: " + res.statusCode);
          console.log("HEADERS: " + (JSON.stringify(res.headers)));
          return res.on('data', function(chunk) {
            return console.log(chunk);
          });
        });
        req.write(data);
        return req.end();
      };
    })(this));
  };

  ezcake.prototype.createOpts = function(cB) {
    cmd.version("version: " + this.version).option("-I, --ignore", "ignore global config file if defined in env.EZCAKE_HOME").option("-O, --no-override", "do not allow loaded configs to override each other").option("-l, --location <paths>", "set path(s) of config file location(s)", function(arg) {
      return arg.split(',');
    });
    return cB();
  };

  ezcake.prototype.getOpts = function(cB) {
    var cnf;
    cnf = this.configs.selectedConfig();
    _.each((ezcake.COMMANDModuleArr = [].concat(cnf.modules || [], cnf.commands || [], cnf.bundles || [])), (function(_this) {
      return function(v, k) {
        var c, t;
        if ((t = _.findWhere([].concat((c = _this.configs.getConfig()).modules, c.commands, c.bundles), {
          name: v.name
        })) != null) {
          if ((t.command != null) && t.command instanceof Array && t.command.length > 1) {
            cmd.option(t.command[0], t.command[1]);
          } else {
            return ezcake.error("command element for config " + cnf.name + " was " + (typeof t.command === 'undefined' ? 'missing' : 'malformed'));
          }
          if ((_.indexOf(t.command[1])) > -1 || process.argv[process.argv.length - 1].match(new RegExp("[" + (t.command[0].charAt(1)) + "]+"))) {
            if (typeof t.setFlag !== 'undefined' && (t.setFlag != null)) {
              return process.argv.push(t.setFlag);
            }
          }
        } else {
          return ezcake.error("" + (v.name || 'object') + " was not defined");
        }
      };
    })(this));
    return cB();
  };

  ezcake.prototype.help = function() {
    var idx;
    if ((idx = process.argv.indexOf('-h')) > -1) {
      return process.argv.splice(2, idx - 2);
    }
  };

  ConfigLoader = (function() {
    function ConfigLoader() {
      this.__loader = require_tree(null);
      this.__config = {};
    }

    ConfigLoader.prototype.getConfigurations = function() {
      return this.__config.configurations;
    };

    ConfigLoader.prototype.getConfig = function() {
      return this.__config;
    };

    ConfigLoader.prototype.loadConfig = function(p, cB) {
      if (p === '.') {
        p = process.cwd();
      }
      return fs.exists((p = path.normalize(p)), (function(_this) {
        return function(bool) {
          var addPath, callBack, e;
          if (!bool) {
            return ezcake.warn("config file " + p + " was not found");
          }
          addPath = p.split(path.sep).pop();
          callBack = function(d) {
            if (_.isArray(_this.__loader.require_tree.loadedConfigs)) {
              _this.__loader.require_tree.loadedConfigs.push(addPath);
            } else {
              _this.__loader.require_tree.loadedConfigs = [addPath];
            }
            _this.__loader.require_tree.off('changed');
            return cB();
          };
          _this.__loader.require_tree.on('changed', callBack);
          try {
            return _this.__loader.require_tree.addTree(p);
          } catch (_error) {
            e = _error;
            return ezcake.error("Failed to load config file '" + p + "'. [" + e + "]");
          }
        };
      })(this));
    };

    ConfigLoader.prototype.extendConfigurations = function() {
      return _.each(this.__config.configurations, (function(_this) {
        return function(v, k) {
          var x;
          if ((v.inherits != null) && ((x = _.findWhere(_this.__config.configurations, {
            name: v.inherits
          })) != null)) {
            return _this.__config.configurations[k] = _.extend(_.clone(x), v);
          }
        };
      })(this));
    };

    ConfigLoader.prototype.selectedConfig = function() {
      var c, conf, e;
      conf = {};
      try {
        _.each(_.keys(c = _.findWhere(this.__config.configurations, {
          name: ezcake.CONFIG
        })), (function(_this) {
          return function(v, k) {
            return conf[v] = _.map(_this.__config[v], function(cV, cK) {
              return cV;
            });
          };
        })(this));
        return conf = _.extend(conf, {
          bundles: _.filter(this.__config.bundles, (function(_this) {
            return function(o) {
              return _.contains(c.bundles, o.name);
            };
          })(this)),
          modules: _.filter(this.__config.modules, (function(_this) {
            return function(o) {
              return _.contains(c.modules, o.name);
            };
          })(this)),
          tasks: _.filter(this.__config.tasks, (function(_this) {
            return function(o) {
              return _.contains(c.tasks, o.name);
            };
          })(this)),
          options: this.__config.options,
          declarations: this.__config.declarations,
          helpers: this.__config.helpers
        });
      } catch (_error) {
        e = _error;
        return ezcake.error("failed to select configuration '" + ezcake.CONFIG + "'. [" + e + "]");
      }
    };

    ConfigLoader.prototype.mergeConfigs = function(cB) {
      return _.each((cmd['override'] ? this.__loader.require_tree.loadedConfigs : this.__loader.require_tree.loadedConfigs.reverse()), (function(_this) {
        return function(v, k) {
          var pkg;
          return _.each((pkg = _this.__loader.require_tree.getPackage(v)), function(oV, oK) {
            var _base;
            if (_.isObject(pkg[oK]) && !(pkg[oK] instanceof Array)) {
              pkg[oK] = _.map(pkg[oK], function(itmV, itmK) {
                if (itmV.name != null) {
                  return itmV;
                }
              });
            }
            if (pkg[oK] instanceof Array) {
              if ((_base = _this.__config)[oK] == null) {
                _base[oK] = [];
              }
              if (_this.__config[oK] instanceof Array) {
                return _.each(pkg[oK], function(itmV, itmK) {
                  var f;
                  if ((itmV.name != null) && (typeof (f = _.findWhere(_this.__config[oK], {
                    name: itmV.name
                  })) !== 'undefined')) {
                    return _this.__config[oK][_.indexOf(_this.__config[oK], f)] = itmV;
                  } else {
                    return _this.__config[oK].push(_.clone(itmV));
                  }
                });
              } else {
                return _.each(pkg[oK], function(itmV, itmK) {
                  if (itmV.name != null) {
                    return _this.__config[oK] = _.extend(_this.__config[oK] || {}, _.clone(itmV));
                  }
                });
              }
            } else {
              return _this.__config[oK] = typeof pkg[oK] === 'string' ? "" + pkg[oK] : _.extend(_this.__config[oK] || {}, _.clone(pkg[oK]));
            }
          });
        };
      })(this));
    };

    ConfigLoader.prototype.listConfigurations = function() {
      var configs;
      configs = [];
      _.each(this.__loader.require_tree.loadedConfigs, (function(_this) {
        return function(v, k) {
          var pkg;
          if ((pkg = _this.__loader.require_tree.getPackage(v)) != null) {
            return configs = _.union(configs, (!(pkg.configurations instanceof Array) ? _.keys(pkg.configurations) : _.pluck(pkg.configurations, 'name')));
          }
        };
      })(this));
      return configs;
    };

    return ConfigLoader;

  })();

  NPMPackage = (function() {
    function NPMPackage(p) {
      this.pkgPath = path.normalize("" + p + "/package.json");
    }

    NPMPackage.prototype.loadNPMPackage = function(callback) {
      if (this.pkgData != null) {
        callback(null, this.pkgData);
        return;
      }
      return fs.exists(this.pkgPath, (function(_this) {
        return function(bool) {
          if (bool) {
            return fs.readFile(_this.pkgPath, {
              encoding: 'utf-8'
            }, function(e, data) {
              if (data != null) {
                try {
                  _this.pkgData = JSON.parse(data);
                } catch (_error) {
                  e = _error;
                  return ezcake.error("failed to parse package.json. [" + e + "]");
                }
              }
              return typeof callback === "function" ? callback(e, _this.pkgData || null) : void 0;
            });
          } else {
            return _this.initNPMPackage(function(e, data) {
              return typeof callback === "function" ? callback(e, data) : void 0;
            });
          }
        };
      })(this));
    };

    NPMPackage.prototype.saveNPMPackage = function(callback) {
      var e;
      if (!(this.pkgData != null)) {
        return ezcake.error("package data must be defined");
      }
      try {
        return fs.writeFile(this.pkgPath, JSON.stringify(this.pkgData, null, 2), {
          encoding: 'utf-8'
        }, (function(_this) {
          return function(e, data) {
            return typeof callback === "function" ? callback(e, _this.pkgData) : void 0;
          };
        })(this));
      } catch (_error) {
        e = _error;
        return console.err(e.message);
      }
    };

    NPMPackage.prototype.initNPMPackage = function(callback) {
      this.pkgData = {
        name: "" + ezcake.NAME,
        author: "" + ((process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE).split(path.sep).pop()),
        version: '0.0.1',
        dependencies: {},
        devDependencies: {}
      };
      return this.saveNPMPackage(callback);
    };

    NPMPackage.prototype.addDependencies = function(npmItems, dev, callback) {
      if (dev == null) {
        dev = false;
      }
      return this.getDependencies(dev, (function(_this) {
        return function(e, dependencies) {
          if (e != null) {
            return ezcake.error(e);
          }
          _.each((npmItems instanceof Array ? npmItems : [npmItems]), function(npmItem, k) {
            var itm;
            if (!_.isObject(npmItem)) {
              return ezcake.error('npmItem must be an object');
            }
            itm = NPMPackage.npmItem(npmItem.name, npmItem.version, npmItem.url);
            if (dependencies[itm.name] != null) {
              return dependencies[npmItem.name] = itm[npmItem.name];
            } else {
              return _.extend(dependencies, itm);
            }
          });
          return _this.saveNPMPackage(callback);
        };
      })(this));
    };

    NPMPackage.prototype.removeDependencies = function(npmItems, dev, callback) {
      if (dev == null) {
        dev = false;
      }
      if (!_.isObject(npmItem)) {
        return ezcake.error('npmItem should be an object');
      }
      return this.getDependencies(dev, (function(_this) {
        return function(e, dependencies) {
          if (e != null) {
            return ezcake.error(e);
          }
          _.each((npmItems instanceof Array ? npmItems : [npmItems]), function(npmItem, k) {
            if (!_.isObject(npmItem)) {
              return ezcake.error('npmItem must be an object');
            }
            return _.each(npmItem, function(v, key) {
              return delete dependencies[k];
            });
          });
          return _this.saveNPMPackage(callback);
        };
      })(this));
    };

    NPMPackage.prototype.getDependencies = function(dev, callback) {
      if (dev == null) {
        dev = false;
      }
      return this.loadNPMPackage((function(_this) {
        return function(e, pkg) {
          return typeof callback === "function" ? callback(e, !dev ? pkg.dependencies != null ? pkg.dependencies : pkg.dependencies = {} : pkg.devDependencies != null ? pkg.devDependencies : pkg.devDependencies = {}) : void 0;
        };
      })(this));
    };

    return NPMPackage;

  })();

  NPMPackage.npmItem = function(name, version, url) {
    var o;
    if (!name) {
      return ezcake.error('node module name is required');
    }
    (o = {})[name] = (url != null ? url : version) || '*';
    return o;
  };

  Processor = (function() {
    function Processor(selectedConfig) {
      this.selectedConfig = selectedConfig;
    }

    Processor.prototype.hasDependencies = function() {
      var config, missing;
      delete (config = _.clone(this.selectedConfig)).options;
      missing = [];
      _.each(_.flatten(_.compact(_.pluck(_.compact(_.flatten(config)), 'dependencies'))), (function(_this) {
        return function(val, key) {
          if (!(_.findWhere(_.compact(_.flatten(config)), {
            name: val.name
          }))) {
            return missing.push(val.name);
          }
        };
      })(this));
      if (missing.length) {
        return missing;
      } else {
        return false;
      }
    };

    Processor.prototype.getModCommands = function() {
      return this.selectedConfig.modules.concat(this.selectedConfig.commands);
    };

    Processor.prototype.getRequires = function() {
      var arr;
      arr = _.flatten(_.compact(_.map(this.selectedConfig, (function(_this) {
        return function(v) {
          var a;
          if ((a = _.compact(_.pluck(v, 'requires'))).length) {
            return a;
          } else {
            return null;
          }
        };
      })(this))));
      return _.map(_.reject(arr, (function(_this) {
        return function(obj, key, list) {
          return !(ezcake.utils.is_intrinsic(obj.name)) || _.compact(_.map(list.slice(key + 1, list.length), function(v, k) {
            if (_.isEqual(obj, v)) {
              return true;
            }
          })).length > 0;
        };
      })(this)), (function(_this) {
        return function(o) {
          if (o.type == null) {
            o.type = 'npm';
          }
          return o;
        };
      })(this));
    };

    Processor.prototype.getDependencies = function() {
      return _.compact(_.map(this.selectedConfig.modules, function(v, k) {
        var name, _ref, _ref1, _ref2;
        name = ((_ref = v.installer_options) != null ? _ref.alias : void 0) || v.name;
        if ((!v.installer || v.installer === 'npm') && ezcake.utils.is_intrinsic(name)) {
          return null;
        }
        return {
          type: v.installer || 'npm',
          name: name,
          version: ((_ref1 = v.installer_options) != null ? _ref1.version : void 0) || '*',
          development: ((_ref2 = v.installer_options) != null ? _ref2.development : void 0) || false
        };
      }));
    };

    Processor.prototype.getPaths = function() {
      var paths;
      paths = {};
      _.each(this.getModCommands().concat(this.selectedConfig.tasks), function(v, k) {
        if (v.paths != null) {
          return paths[v.name] = v.paths;
        }
      });
      return paths;
    };

    Processor.prototype.getFiles = function() {
      var files;
      files = {};
      _.each(this.getModCommands(), function(v, k) {
        if (v.files != null) {
          return files[v.name] = v.files;
        }
      });
      return files;
    };

    Processor.prototype.getExts = function() {
      return (_.compact(_.pluck(this.selectedConfig.modules, 'ext'))).join('|');
    };

    Processor.prototype.getInvocations = function() {
      return _.filter(this.getModCommands(), function(o) {
        return o.invocations != null;
      });
    };

    Processor.prototype.getCallbacks = function() {
      var callbacks, mC;
      mC = this.getModCommands();
      callbacks = [];
      _.each(_.map(_.compact(_.pluck(mC, 'callback')), function(v, k) {
        return {
          name: "on" + (v.charAt(0).toUpperCase()) + (v.slice(1)),
          invocations: []
        };
      }), (function(_this) {
        return function(v, k) {
          callbacks[k] = v;
          return _.each(_.filter(mC, function(o) {
            return o.invocations != null;
          }), function(fV, fK) {
            return _.each(_.filter(fV.invocations, function(o) {
              return o.call === v.name;
            }), function(iV, iK) {
              return callbacks[k].invocations.push({
                callee: fV.name,
                body: iV.body
              });
            });
          });
        };
      })(this));
      return callbacks;
    };

    Processor.prototype.processTasks = function() {
      var m;
      m = this.getInvocations();
      return _.each(this.selectedConfig.tasks, (function(_this) {
        return function(v, k) {
          var name;
          name = "on" + (v.name.charAt(0).toUpperCase()) + (v.name.slice(1));
          _this.selectedConfig.tasks[k].invocations = [];
          return _.each(m, function(fV, fK) {
            return _.each(_.filter(fV.invocations, function(o) {
              return o.call === name;
            }), function(iV, iK) {
              var callback;
              if (fV.callback) {
                callback = "on" + (fV.callback.charAt(0).toUpperCase()) + (fV.callback.slice(1));
              }
              if (iV.body.length) {
                return _this.selectedConfig.tasks[k].invocations.push({
                  callee: fV.name,
                  body: iV.body,
                  callback: callback || null
                });
              }
            });
          });
        };
      })(this));
    };

    Processor.prototype.getDeclarations = function() {
      var src;
      src = "";
      _.each(this.selectedConfig.declarations, (function(_this) {
        return function(v, k) {
          return src = "" + src + "\n\n" + (_this.template(path.join(_this.module_path, 'templates/_declaration.template.txt'), v));
        };
      })(this));
      return src;
    };

    Processor.prototype.generateConfiguration = function() {
      var bundles, deps, reqs;
      if ((bundles = this.selectedConfig.bundles) != null) {
        _.each(bundles, (function(_this) {
          return function(v, k) {
            console.log("bundle name: " + v.name);
            if (cmd[v.name]) {
              return _.each(v, function(bV, bK) {
                var m, _base;
                console.log("bK: " + bK);
                if (!(typeof bV === 'string')) {
                  if (bK !== 'templates') {
                    console.log("bK: " + bK);
                    if ((_base = _this.selectedConfig)[bK] == null) {
                      _base[bK] = [];
                    }
                    if (_.isArray(bV)) {
                      return _.each(bV, function(nV, nK) {
                        if ((nV.name != null) && nV.name !== "") {
                          return _this.selectedConfig[bK].push(nV);
                        }
                      });
                    } else {
                      if (ezcake.utils.is_config_element(bK)) {
                        return _.each(bV, function(nV, nK) {
                          if ((nV.name != null) && nV.name !== "") {
                            return _this.selectedConfig[bK].push(nV);
                          }
                        });
                      } else {
                        if ((bV.name != null) && bV.name !== "") {
                          return _this.selectedConfig[bK].push(bV);
                        }
                      }
                    }
                  } else {
                    (m = {})[v.name] = bV;
                    if (_.isObject(bV)) {
                      return _this.selectedConfig[bK] = _.extend(_this.selectedConfig[bK] || {}, m);
                    }
                  }
                }
              });
            }
          };
        })(this));
      }
      this.processTasks();
      if (deps = this.hasDependencies()) {
        ezcake.error("missing the following dependiences: " + deps);
      }
      return _.extend(this.selectedConfig, {
        reqs: (reqs = _.where(this.getRequires(), {
          type: 'npm'
        })),
        version: this.version,
        paths: this.getPaths(),
        exts: this.getExts(),
        callbacks: this.getCallbacks(),
        options: this.selectedConfig.options || [],
        templates: JSON.stringify(this.selectedConfig.templates || {}, null, 2)
      });
    };

    return Processor;

  })();

  FileHelpers = (function() {
    function FileHelpers(basePath) {
      this.basePath = basePath;
    }

    FileHelpers.prototype.createPaths = function(paths, callback) {
      var cnt;
      cnt = 0;
      return _.each(_.flatten((paths != null ? paths : paths = []) instanceof Array ? paths : [paths]), (function(_this) {
        return function(v, k) {
          var p;
          return fs.mkdirs(path.normalize(p = "" + _this.basePath + "/" + v), function(e) {
            if (e != null) {
              ezcake.error("Failed to create path '" + p + "'. [" + e + "]");
            }
            if ((cnt = cnt + 1) === paths.length) {
              return typeof callback === "function" ? callback() : void 0;
            }
          });
        };
      })(this));
    };

    FileHelpers.prototype.createFiles = function(paths, callback) {
      var cnt;
      cnt = 0;
      return _.each(_.flatten((paths != null ? paths : paths = []) instanceof Array ? paths : [paths]), (function(_this) {
        return function(v, k) {
          var p;
          return fs.createFile(path.normalize(p = "" + _this.basePath + "/" + v), function(e) {
            if (e != null) {
              ezcake.error("Failed to create file '" + p + "'. [" + e + "]");
            }
            if ((cnt = cnt + 1) === paths.length) {
              return typeof callback === "function" ? callback() : void 0;
            }
          });
        };
      })(this));
    };

    return FileHelpers;

  })();

  CakefileRenderer = (function() {
    function CakefileRenderer(cakefilePath, templatePath) {
      this.cakefilePath = cakefilePath;
      this.templatePath = templatePath;
    }

    CakefileRenderer.prototype.__fetchTemplate = function(data, callback) {
      return fs.readFile(path.normalize(this.templatePath), {
        encoding: 'utf-8'
      }, (function(_this) {
        return function(e, fData) {
          if (e != null) {
            ezcake.error("Failed to fetch Cakefile Template. [" + e + "]");
          }
          try {
            fData = _.template(fData, data);
          } catch (_error) {
            e = _error;
            ezcake.error("Failed to parse Cakefile Template. [" + e + "]");
          }
          if (callback && typeof callback === 'function') {
            return callback(fData);
          }
        };
      })(this));
    };

    CakefileRenderer.prototype.render = function(data, callback) {
      return this.__fetchTemplate(data, (function(_this) {
        return function(rendered) {
          return fs.writeFile(path.normalize("" + _this.cakefilePath + "/Cakefile"), rendered, null, function(e) {
            if (e != null) {
              ezcake.error("Failed to write Cakefile [" + e + "]");
            }
            return callback(null);
          });
        };
      })(this));
    };

    return CakefileRenderer;

  })();

  ezcake.strings = {
    hash: '#',
    red: '\u001b[31m',
    green: '\u001b[32m',
    yellow: '\u001b[33m',
    reset: '\u001b[0m'
  };

  ezcake.log = function(m) {
    return process.stdout.write("" + m + "\n");
  };

  ezcake.warn = function(m) {
    return process.stdout.write("" + ezcake.strings.yellow + m + ezcake.strings.reset + "\n");
  };

  ezcake.error = function(m) {
    process.stderr.write("" + ezcake.strings.red + "Error: " + m + ezcake.strings.reset + "\n");
    return process.exit(1);
  };

  ezcake.utils = {
    replaceAll: function(str, map) {
      return str.replace(new RegExp("^" + (_.keys(map).join('|')) + "$", 'i'), (function(_this) {
        return function(matched) {
          return map[matched.toLowerCase()];
        };
      })(this));
    },
    is_intrinsic: function(itm) {
      return ['assert', 'buffer', 'child_process', 'cluster', 'console', 'crypto', 'debugger', 'dns', 'domain', 'emitter', 'fs', 'http', 'https', 'net', 'os', 'path', 'process', 'punycode', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'tls', 'dgram', 'url', 'util', 'vm', 'zlib'].lastIndexOf(itm) > -1;
    },
    is_config_element: function(itm) {
      return ['bundles', 'commands', 'configurations', 'helpers', 'modules', 'options', 'tasks', 'templates'].lastIndexOf(itm) > -1;
    }
  };

  path = require('path');

  http = require('http');

  fs = require('fs-extra');

  async = require('async');

  cmd = require('commander');

  require_tree = require('require_tree').require_tree;

  _ = require('underscore');

  exports.EzCake = ezcake;

  if (process && process.argv && process.argv[1].split('/').pop() === 'ezcake') {
    new ezcake;
  }

}).call(this);
